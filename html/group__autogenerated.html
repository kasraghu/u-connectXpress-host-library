<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>u-connectXpress host library: Callback registration</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ublox-logo.webp"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">u-connectXpress host library
   &#160;<span id="projectnumber">0.4</span>
   </div>
   <div id="projectbrief">AT and EDM parser for u-blox shortrange standalone modules</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__autogenerated.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Callback registration<div class="ingroups"><a class="el" href="group__communication.html">Communication with the module</a> &raquo; <a class="el" href="group__callbacks.html">Callbacks</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Autogenerated functions for callback registration.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7c7062b8d1041f243f6368138dc50337"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga7c7062b8d1041f243f6368138dc50337">ucxhPARSER_setOnManufacturerIdentification</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_manufacturer_identification_event__t.html">ucxhPARSER_urcManufacturerIdentificationEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:ga7c7062b8d1041f243f6368138dc50337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke upon reception of the <code>+GMI</code> URC or command response for <code>Manufacturer Identification</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga7c7062b8d1041f243f6368138dc50337">More...</a><br /></td></tr>
<tr class="separator:ga7c7062b8d1041f243f6368138dc50337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedb16ab618f1d4e7d9af1d819ce3af67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#gaedb16ab618f1d4e7d9af1d819ce3af67">ucxhPARSER_setOnGMIError</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:gaedb16ab618f1d4e7d9af1d819ce3af67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke in case the command <code>AT+GMI</code> for <code>Manufacturer Identification</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead.  <a href="group__autogenerated.html#gaedb16ab618f1d4e7d9af1d819ce3af67">More...</a><br /></td></tr>
<tr class="separator:gaedb16ab618f1d4e7d9af1d819ce3af67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04e601fa515d5431d13645aa610ab425"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga04e601fa515d5431d13645aa610ab425">ucxhPARSER_setOnModelIdentification</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_model_identification_event__t.html">ucxhPARSER_urcModelIdentificationEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:ga04e601fa515d5431d13645aa610ab425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke upon reception of the <code>+GMM</code> URC or command response for <code>Model Identification</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga04e601fa515d5431d13645aa610ab425">More...</a><br /></td></tr>
<tr class="separator:ga04e601fa515d5431d13645aa610ab425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a629376b14c77ec1eacbfc3a0e13f2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga7a629376b14c77ec1eacbfc3a0e13f2a">ucxhPARSER_setOnGMMError</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:ga7a629376b14c77ec1eacbfc3a0e13f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke in case the command <code>AT+GMM</code> for <code>Model Identification</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga7a629376b14c77ec1eacbfc3a0e13f2a">More...</a><br /></td></tr>
<tr class="separator:ga7a629376b14c77ec1eacbfc3a0e13f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7cc459922610a3f978cb8687f5dccce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#gad7cc459922610a3f978cb8687f5dccce">ucxhPARSER_setOnSoftwareVersionIdentification</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_software_version_identification_event__t.html">ucxhPARSER_urcSoftwareVersionIdentificationEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:gad7cc459922610a3f978cb8687f5dccce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke upon reception of the <code>+GMR</code> URC or command response for <code>Software Version Identification</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead.  <a href="group__autogenerated.html#gad7cc459922610a3f978cb8687f5dccce">More...</a><br /></td></tr>
<tr class="separator:gad7cc459922610a3f978cb8687f5dccce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga516226aeaff5d4feb125430c754d2945"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga516226aeaff5d4feb125430c754d2945">ucxhPARSER_setOnGMRError</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:ga516226aeaff5d4feb125430c754d2945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke in case the command <code>AT+GMR</code> for <code>Software Version Identification</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga516226aeaff5d4feb125430c754d2945">More...</a><br /></td></tr>
<tr class="separator:ga516226aeaff5d4feb125430c754d2945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9def56fdbc269521fd364f7e3da29a0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga9def56fdbc269521fd364f7e3da29a0f">ucxhPARSER_setOnSerialNumber</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_serial_number_event__t.html">ucxhPARSER_urcSerialNumberEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:ga9def56fdbc269521fd364f7e3da29a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke upon reception of the <code>+GSN</code> URC or command response for <code>Serial Number</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga9def56fdbc269521fd364f7e3da29a0f">More...</a><br /></td></tr>
<tr class="separator:ga9def56fdbc269521fd364f7e3da29a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a14463f4e1de22bcaaf150cb2925f6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga3a14463f4e1de22bcaaf150cb2925f6e">ucxhPARSER_setOnGSNError</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:ga3a14463f4e1de22bcaaf150cb2925f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke in case the command <code>AT+GSN</code> for <code>Serial Number</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga3a14463f4e1de22bcaaf150cb2925f6e">More...</a><br /></td></tr>
<tr class="separator:ga3a14463f4e1de22bcaaf150cb2925f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf633d6a1b6b6caa7e7f0389cfe0ba1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga0cf633d6a1b6b6caa7e7f0389cfe0ba1">ucxhPARSER_setOnTypeCodeIdentification</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_type_code_identification_event__t.html">ucxhPARSER_urcTypeCodeIdentificationEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:ga0cf633d6a1b6b6caa7e7f0389cfe0ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke upon reception of the <code>+I0</code> URC or command response for <code>Type Code Identification</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga0cf633d6a1b6b6caa7e7f0389cfe0ba1">More...</a><br /></td></tr>
<tr class="separator:ga0cf633d6a1b6b6caa7e7f0389cfe0ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga171bebc5bd825e69f29e1e7b73669e42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga171bebc5bd825e69f29e1e7b73669e42">ucxhPARSER_setOnI0Error</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:ga171bebc5bd825e69f29e1e7b73669e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke in case the command <code>AT+I0</code> for <code>Type Code Identification</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga171bebc5bd825e69f29e1e7b73669e42">More...</a><br /></td></tr>
<tr class="separator:ga171bebc5bd825e69f29e1e7b73669e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d9ec6fabf5935bb15254de3f26729f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga2d9ec6fabf5935bb15254de3f26729f1">ucxhPARSER_setOnIdentificationInformation</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_identification_information_event__t.html">ucxhPARSER_urcIdentificationInformationEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:ga2d9ec6fabf5935bb15254de3f26729f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke upon reception of the <code>+I9</code> URC or command response for <code>Identification Information</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga2d9ec6fabf5935bb15254de3f26729f1">More...</a><br /></td></tr>
<tr class="separator:ga2d9ec6fabf5935bb15254de3f26729f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga594e928f9ea1dae09aec617078d70689"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga594e928f9ea1dae09aec617078d70689">ucxhPARSER_setOnI9Error</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:ga594e928f9ea1dae09aec617078d70689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke in case the command <code>AT+I9</code> for <code>Identification Information</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga594e928f9ea1dae09aec617078d70689">More...</a><br /></td></tr>
<tr class="separator:ga594e928f9ea1dae09aec617078d70689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dc311b2309bce52db2c240c4462f61d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga4dc311b2309bce52db2c240c4462f61d">ucxhPARSER_setOnMcuIdentification</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_mcu_identification_event__t.html">ucxhPARSER_urcMcuIdentificationEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:ga4dc311b2309bce52db2c240c4462f61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke upon reception of the <code>+I10</code> URC or command response for <code>MCU Identification</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga4dc311b2309bce52db2c240c4462f61d">More...</a><br /></td></tr>
<tr class="separator:ga4dc311b2309bce52db2c240c4462f61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a16d5eae8fd6ba4c7d657011de369ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga0a16d5eae8fd6ba4c7d657011de369ac">ucxhPARSER_setOnI10Error</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:ga0a16d5eae8fd6ba4c7d657011de369ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke in case the command <code>AT+I10</code> for <code>MCU Identification</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga0a16d5eae8fd6ba4c7d657011de369ac">More...</a><br /></td></tr>
<tr class="separator:ga0a16d5eae8fd6ba4c7d657011de369ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ddb8616263bb68c3fd42ca4628c6cf1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga0ddb8616263bb68c3fd42ca4628c6cf1">ucxhPARSER_setOnStartup</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_startup_event__t.html">ucxhPARSER_urcStartupEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:ga0ddb8616263bb68c3fd42ca4628c6cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke upon reception of the <code>+STARTUP</code> URC or command response for <code>Startup</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga0ddb8616263bb68c3fd42ca4628c6cf1">More...</a><br /></td></tr>
<tr class="separator:ga0ddb8616263bb68c3fd42ca4628c6cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad710f78de8dcea7213764abb79122ec6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#gad710f78de8dcea7213764abb79122ec6">ucxhPARSER_setOnSTARTUPError</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:gad710f78de8dcea7213764abb79122ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke in case the command <code>AT+STARTUP</code> for <code>Startup</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead.  <a href="group__autogenerated.html#gad710f78de8dcea7213764abb79122ec6">More...</a><br /></td></tr>
<tr class="separator:gad710f78de8dcea7213764abb79122ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6cbcae2b205d6067d52926e7ffd375e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#gac6cbcae2b205d6067d52926e7ffd375e">ucxhPARSER_setOnConnectPeer</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_connect_peer_event__t.html">ucxhPARSER_urcConnectPeerEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:gac6cbcae2b205d6067d52926e7ffd375e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke upon reception of the <code>+UDCP</code> URC or command response for <code>Connect Peer</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead.  <a href="group__autogenerated.html#gac6cbcae2b205d6067d52926e7ffd375e">More...</a><br /></td></tr>
<tr class="separator:gac6cbcae2b205d6067d52926e7ffd375e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c59be527d84f8bc897136eb1f568d93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga8c59be527d84f8bc897136eb1f568d93">ucxhPARSER_setOnUDCPError</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:ga8c59be527d84f8bc897136eb1f568d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke in case the command <code>AT+UDCP</code> for <code>Connect Peer</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga8c59be527d84f8bc897136eb1f568d93">More...</a><br /></td></tr>
<tr class="separator:ga8c59be527d84f8bc897136eb1f568d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25a6f80423227ce82a2a39d5237712ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga25a6f80423227ce82a2a39d5237712ed">ucxhPARSER_setOnLocalAddress</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_local_address_event__t.html">ucxhPARSER_urcLocalAddressEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:ga25a6f80423227ce82a2a39d5237712ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke upon reception of the <code>+UMLA</code> URC or command response for <code>Local address</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga25a6f80423227ce82a2a39d5237712ed">More...</a><br /></td></tr>
<tr class="separator:ga25a6f80423227ce82a2a39d5237712ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga778e275d844ec97607dc2ba6b1337db2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga778e275d844ec97607dc2ba6b1337db2">ucxhPARSER_setOnUMLAError</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:ga778e275d844ec97607dc2ba6b1337db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke in case the command <code>AT+UMLA</code> for <code>Local address</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga778e275d844ec97607dc2ba6b1337db2">More...</a><br /></td></tr>
<tr class="separator:ga778e275d844ec97607dc2ba6b1337db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1540d5c6f750c71e015d108a454d6f27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga1540d5c6f750c71e015d108a454d6f27">ucxhPARSER_setOnNetworkStatus</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_network_status_event__t.html">ucxhPARSER_urcNetworkStatusEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:ga1540d5c6f750c71e015d108a454d6f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke upon reception of the <code>+UNSTAT</code> URC or command response for <code>Network Status</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga1540d5c6f750c71e015d108a454d6f27">More...</a><br /></td></tr>
<tr class="separator:ga1540d5c6f750c71e015d108a454d6f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb80d1ab11f395f97bf2e98590a68503"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#gacb80d1ab11f395f97bf2e98590a68503">ucxhPARSER_setOnUNSTATError</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:gacb80d1ab11f395f97bf2e98590a68503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke in case the command <code>AT+UNSTAT</code> for <code>Network Status</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead.  <a href="group__autogenerated.html#gacb80d1ab11f395f97bf2e98590a68503">More...</a><br /></td></tr>
<tr class="separator:gacb80d1ab11f395f97bf2e98590a68503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga620eae018d67b54d143ed3f4edaffe01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga620eae018d67b54d143ed3f4edaffe01">ucxhPARSER_setOnPeerConnected</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_peer_connected_event__t.html">ucxhPARSER_urcPeerConnectedEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:ga620eae018d67b54d143ed3f4edaffe01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke upon reception of the <code>+UUDPC</code> URC or command response for <code>Peer Connected</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga620eae018d67b54d143ed3f4edaffe01">More...</a><br /></td></tr>
<tr class="separator:ga620eae018d67b54d143ed3f4edaffe01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc808efca98250ba976ccabb43ee7224"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#gacc808efca98250ba976ccabb43ee7224">ucxhPARSER_setOnUUDPCError</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:gacc808efca98250ba976ccabb43ee7224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke in case the command <code>AT+UUDPC</code> for <code>Peer Connected</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead.  <a href="group__autogenerated.html#gacc808efca98250ba976ccabb43ee7224">More...</a><br /></td></tr>
<tr class="separator:gacc808efca98250ba976ccabb43ee7224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fbfc01255c3e41493ba08c49172fcb4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga0fbfc01255c3e41493ba08c49172fcb4">ucxhPARSER_setOnPeerDisconnected</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_peer_disconnected_event__t.html">ucxhPARSER_urcPeerDisconnectedEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:ga0fbfc01255c3e41493ba08c49172fcb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke upon reception of the <code>+UUDPD</code> URC or command response for <code>Peer Disconnected</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga0fbfc01255c3e41493ba08c49172fcb4">More...</a><br /></td></tr>
<tr class="separator:ga0fbfc01255c3e41493ba08c49172fcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fcaed6fd74f0a6b540c471547e46dc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga2fcaed6fd74f0a6b540c471547e46dc6">ucxhPARSER_setOnUUDPDError</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:ga2fcaed6fd74f0a6b540c471547e46dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke in case the command <code>AT+UUDPD</code> for <code>Peer Disconnected</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga2fcaed6fd74f0a6b540c471547e46dc6">More...</a><br /></td></tr>
<tr class="separator:ga2fcaed6fd74f0a6b540c471547e46dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdf48b5aa2f1ca7bef03d4f5d594b0ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#gabdf48b5aa2f1ca7bef03d4f5d594b0ee">ucxhPARSER_setOnNetworkDown</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_network_down_event__t.html">ucxhPARSER_urcNetworkDownEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:gabdf48b5aa2f1ca7bef03d4f5d594b0ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke upon reception of the <code>+UUND</code> URC or command response for <code>Network Down</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead.  <a href="group__autogenerated.html#gabdf48b5aa2f1ca7bef03d4f5d594b0ee">More...</a><br /></td></tr>
<tr class="separator:gabdf48b5aa2f1ca7bef03d4f5d594b0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a9b993e8ba5dffe67ab39eb657239fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga8a9b993e8ba5dffe67ab39eb657239fb">ucxhPARSER_setOnUUNDError</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:ga8a9b993e8ba5dffe67ab39eb657239fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke in case the command <code>AT+UUND</code> for <code>Network Down</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga8a9b993e8ba5dffe67ab39eb657239fb">More...</a><br /></td></tr>
<tr class="separator:ga8a9b993e8ba5dffe67ab39eb657239fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2f48aa8352053041484f27134872d8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#gab2f48aa8352053041484f27134872d8f">ucxhPARSER_setOnNetworkUp</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_network_up_event__t.html">ucxhPARSER_urcNetworkUpEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:gab2f48aa8352053041484f27134872d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke upon reception of the <code>+UUNU</code> URC or command response for <code>Network Up</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead.  <a href="group__autogenerated.html#gab2f48aa8352053041484f27134872d8f">More...</a><br /></td></tr>
<tr class="separator:gab2f48aa8352053041484f27134872d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54aeacecd8f34ba2b34e384459fdd7f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga54aeacecd8f34ba2b34e384459fdd7f9">ucxhPARSER_setOnUUNUError</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:ga54aeacecd8f34ba2b34e384459fdd7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke in case the command <code>AT+UUNU</code> for <code>Network Up</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga54aeacecd8f34ba2b34e384459fdd7f9">More...</a><br /></td></tr>
<tr class="separator:ga54aeacecd8f34ba2b34e384459fdd7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd5f9327421dd522646c7ebf842d6290"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#gafd5f9327421dd522646c7ebf842d6290">ucxhPARSER_setOnWifiLinkDisconnected</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_wifi_link_disconnected_event__t.html">ucxhPARSER_urcWifiLinkDisconnectedEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:gafd5f9327421dd522646c7ebf842d6290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke upon reception of the <code>+UUWLD</code> URC or command response for <code>WiFi Link Disconnected</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead.  <a href="group__autogenerated.html#gafd5f9327421dd522646c7ebf842d6290">More...</a><br /></td></tr>
<tr class="separator:gafd5f9327421dd522646c7ebf842d6290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5d5dfe7ec72dc1853b3fc29b4f02f4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#gaf5d5dfe7ec72dc1853b3fc29b4f02f4d">ucxhPARSER_setOnUUWLDError</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:gaf5d5dfe7ec72dc1853b3fc29b4f02f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke in case the command <code>AT+UUWLD</code> for <code>WiFi Link Disconnected</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead.  <a href="group__autogenerated.html#gaf5d5dfe7ec72dc1853b3fc29b4f02f4d">More...</a><br /></td></tr>
<tr class="separator:gaf5d5dfe7ec72dc1853b3fc29b4f02f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17f6ec7beabc9ba578dc08894f92bada"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga17f6ec7beabc9ba578dc08894f92bada">ucxhPARSER_setOnWifiLinkConnected</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_wifi_link_connected_event__t.html">ucxhPARSER_urcWifiLinkConnectedEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:ga17f6ec7beabc9ba578dc08894f92bada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke upon reception of the <code>+UUWLE</code> URC or command response for <code>WiFi Link Connected</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga17f6ec7beabc9ba578dc08894f92bada">More...</a><br /></td></tr>
<tr class="separator:ga17f6ec7beabc9ba578dc08894f92bada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46c25f6b8cb454b4b99b032278082f3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga46c25f6b8cb454b4b99b032278082f3c">ucxhPARSER_setOnUUWLEError</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:ga46c25f6b8cb454b4b99b032278082f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke in case the command <code>AT+UUWLE</code> for <code>WiFi Link Connected</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga46c25f6b8cb454b4b99b032278082f3c">More...</a><br /></td></tr>
<tr class="separator:ga46c25f6b8cb454b4b99b032278082f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58642e44a4e0df5d8bd2395704afa051"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga58642e44a4e0df5d8bd2395704afa051">ucxhPARSER_setOnWifiStationConfiguration</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_wifi_station_configuration_event__t.html">ucxhPARSER_urcWifiStationConfigurationEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:ga58642e44a4e0df5d8bd2395704afa051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke upon reception of the <code>+UWSC</code> URC or command response for <code>WiFi Station Configuration</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga58642e44a4e0df5d8bd2395704afa051">More...</a><br /></td></tr>
<tr class="separator:ga58642e44a4e0df5d8bd2395704afa051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a9527fddbaa4ac2452cffe550c04904"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga9a9527fddbaa4ac2452cffe550c04904">ucxhPARSER_setOnUWSCError</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:ga9a9527fddbaa4ac2452cffe550c04904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke in case the command <code>AT+UWSC</code> for <code>WiFi Station Configuration</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga9a9527fddbaa4ac2452cffe550c04904">More...</a><br /></td></tr>
<tr class="separator:ga9a9527fddbaa4ac2452cffe550c04904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d24d8e8dc9fd9e44f5efb4b49902fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#gae5d24d8e8dc9fd9e44f5efb4b49902fa">ucxhPARSER_setOnWifiScan</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_wifi_scan_event__t.html">ucxhPARSER_urcWifiScanEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:gae5d24d8e8dc9fd9e44f5efb4b49902fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke upon reception of the <code>+UWSCAN</code> URC or command response for <code>WiFi Scan</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead.  <a href="group__autogenerated.html#gae5d24d8e8dc9fd9e44f5efb4b49902fa">More...</a><br /></td></tr>
<tr class="separator:gae5d24d8e8dc9fd9e44f5efb4b49902fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafd42a3e00874cc98f87409ff849f8a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#gaafd42a3e00874cc98f87409ff849f8a1">ucxhPARSER_setOnUWSCANError</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:gaafd42a3e00874cc98f87409ff849f8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke in case the command <code>AT+UWSCAN</code> for <code>WiFi Scan</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead.  <a href="group__autogenerated.html#gaafd42a3e00874cc98f87409ff849f8a1">More...</a><br /></td></tr>
<tr class="separator:gaafd42a3e00874cc98f87409ff849f8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee0b7ebf53c869cc63322273467f8249"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#gaee0b7ebf53c869cc63322273467f8249">ucxhPARSER_setOnWifiStationStatus</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_wifi_station_status_event__t.html">ucxhPARSER_urcWifiStationStatusEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:gaee0b7ebf53c869cc63322273467f8249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke upon reception of the <code>+UWSSTAT</code> URC or command response for <code>WiFi Station Status</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead.  <a href="group__autogenerated.html#gaee0b7ebf53c869cc63322273467f8249">More...</a><br /></td></tr>
<tr class="separator:gaee0b7ebf53c869cc63322273467f8249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23f42d85e3e123b814e2160bfa4e80af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga23f42d85e3e123b814e2160bfa4e80af">ucxhPARSER_setOnUWSSTATError</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:ga23f42d85e3e123b814e2160bfa4e80af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback to invoke in case the command <code>AT+UWSSTAT</code> for <code>WiFi Station Status</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead.  <a href="group__autogenerated.html#ga23f42d85e3e123b814e2160bfa4e80af">More...</a><br /></td></tr>
<tr class="separator:ga23f42d85e3e123b814e2160bfa4e80af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d7d80f6cae90090c604ce5615f6f064"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga1d7d80f6cae90090c604ce5615f6f064">ucxhURC_t</a> { <a class="el" href="group__autogenerated.html#gga1d7d80f6cae90090c604ce5615f6f064aafe2c22bcb47e898b9edcbc2895b0246">uxchURC_LAST</a>, 
<a class="el" href="group__autogenerated.html#gga1d7d80f6cae90090c604ce5615f6f064a5f0c50deb12c8974ce7e70b7d9101320">uxchURC_UNKNOWN</a>
 }</td></tr>
<tr class="memdesc:ga1d7d80f6cae90090c604ce5615f6f064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all URCS, with the defined values <code>uxchURC_XXX</code> , finalized by <a class="el" href="group__autogenerated.html#gga1d7d80f6cae90090c604ce5615f6f064aafe2c22bcb47e898b9edcbc2895b0246">uxchURC_LAST</a> followed by <a class="el" href="group__autogenerated.html#gga1d7d80f6cae90090c604ce5615f6f064a5f0c50deb12c8974ce7e70b7d9101320">uxchURC_UNKNOWN</a>.  <a href="group__autogenerated.html#ga1d7d80f6cae90090c604ce5615f6f064">More...</a><br /></td></tr>
<tr class="separator:ga1d7d80f6cae90090c604ce5615f6f064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga475aa1338c7bccbf139dc2cbcd4c3154"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="ucxh__urc_8h.html#a44fe167118c2a781861ba3efcb020106">LIST_OF_PLUS_URC</a> enum <a class="el" href="group__autogenerated.html#ga1d7d80f6cae90090c604ce5615f6f064">ucxhURC_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga475aa1338c7bccbf139dc2cbcd4c3154">ucxhURC_t</a></td></tr>
<tr class="memdesc:ga475aa1338c7bccbf139dc2cbcd4c3154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all URCS, with the defined values <code>uxchURC_XXX</code> , finalized by <a class="el" href="group__autogenerated.html#gga1d7d80f6cae90090c604ce5615f6f064aafe2c22bcb47e898b9edcbc2895b0246">uxchURC_LAST</a> followed by <a class="el" href="group__autogenerated.html#gga1d7d80f6cae90090c604ce5615f6f064a5f0c50deb12c8974ce7e70b7d9101320">uxchURC_UNKNOWN</a>.  <a href="group__autogenerated.html#ga475aa1338c7bccbf139dc2cbcd4c3154">More...</a><br /></td></tr>
<tr class="separator:ga475aa1338c7bccbf139dc2cbcd4c3154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab90dcd73cc916fda9f699e8d06e6318a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ucxh__urc_8h.html#a44fe167118c2a781861ba3efcb020106">LIST_OF_PLUS_URC</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a">ucxhPARSER_setOnXXX</a> (int(*callback)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_x_x_x_event__t.html">ucxhPARSER_urcXXXEvent_t</a> *pEvent))</td></tr>
<tr class="memdesc:gab90dcd73cc916fda9f699e8d06e6318a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function declaration for registration of callback for an URC or response to a command request named <code>XXX</code>, such as <code>NfcUriTagContent</code>, with the actual URC or command is <code>UUU</code>, such as <code>UNFCURI</code>.  <a href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a">More...</a><br /></td></tr>
<tr class="separator:gab90dcd73cc916fda9f699e8d06e6318a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5b2febba2dbf74fad9eb8a728c26673"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ucxh__urc_8h.html#a44fe167118c2a781861ba3efcb020106">LIST_OF_PLUS_URC</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#gad5b2febba2dbf74fad9eb8a728c26673">ucxhPARSER_setOnXXXOk</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:gad5b2febba2dbf74fad9eb8a728c26673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function declaration for registration of callback invoked when OK is received for a command request named <code>XXX</code>, such as <code>NfcUriTagContent</code>, with the actual command is <code>UUU</code>, such as <code>UNFCURI</code>.  <a href="group__autogenerated.html#gad5b2febba2dbf74fad9eb8a728c26673">More...</a><br /></td></tr>
<tr class="separator:gad5b2febba2dbf74fad9eb8a728c26673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac940a6334ca1ea7cf554c06f3798e961"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ucxh__urc_8h.html#a44fe167118c2a781861ba3efcb020106">LIST_OF_PLUS_URC</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961">ucxhPARSER_setOnXXXError</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:gac940a6334ca1ea7cf554c06f3798e961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function declaration for registration of callback invoked when ERROR is received for a command request named <code>XXX</code>, such as <code>NfcUriTagContent</code>, with the actual command is <code>UUU</code>, such as <code>UNFCURI</code>.  <a href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961">More...</a><br /></td></tr>
<tr class="separator:gac940a6334ca1ea7cf554c06f3798e961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95573632ef17c4111fbe3a552705c10b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ucxh__urc_8h.html#a44fe167118c2a781861ba3efcb020106">LIST_OF_PLUS_URC</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#ga95573632ef17c4111fbe3a552705c10b">ucxhPARSER_internalSetOnUUUOk</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:ga95573632ef17c4111fbe3a552705c10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function declaration for registration of <b>internal</b> callback invoked when OK is received for a command request named <code>XXX</code>, such as <code>NfcUriTagContent</code>, with the actual command is <code>UUU</code>, such as <code>UNFCURI</code>.  <a href="group__autogenerated.html#ga95573632ef17c4111fbe3a552705c10b">More...</a><br /></td></tr>
<tr class="separator:ga95573632ef17c4111fbe3a552705c10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1dca9917b5f5361b44cb699f78bdcb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ucxh__urc_8h.html#a44fe167118c2a781861ba3efcb020106">LIST_OF_PLUS_URC</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#gae1dca9917b5f5361b44cb699f78bdcb8">ucxhPARSER_internalSetOnUUUError</a> (int(*callback)(void *_))</td></tr>
<tr class="memdesc:gae1dca9917b5f5361b44cb699f78bdcb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function declaration for registration of <b>internal</b> callback invoked when ERROR is received for a command request named <code>XXX</code>, such as <code>NfcUriTagContent</code>, with the actual command is <code>UUU</code>, such as <code>UNFCURI</code>.  <a href="group__autogenerated.html#gae1dca9917b5f5361b44cb699f78bdcb8">More...</a><br /></td></tr>
<tr class="separator:gae1dca9917b5f5361b44cb699f78bdcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf2b167887891e46105e6462a1d0acb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ucxh__urc_8h.html#a44fe167118c2a781861ba3efcb020106">LIST_OF_PLUS_URC</a> <a class="el" href="ucxh__urc_8h.html#aa90077b35ac464b34ccee14ada3ceb65">ucxhURC_parseResult_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__autogenerated.html#gaaf2b167887891e46105e6462a1d0acb8">onUUU_createEvent</a> (uint8_t numParams, const char *ppParams[], <a class="el" href="structucxh_p_a_r_s_e_r__urc_x_x_x_event__t.html">ucxhPARSER_urcXXXEvent_t</a> *pEvent)</td></tr>
<tr class="memdesc:gaaf2b167887891e46105e6462a1d0acb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function declaration for a function which parses a line to create an event for a URC or reponse to a command request <code>XXX</code>, such as <code>NfcUriTagContent</code>, with the actual URN or command is <code>UUU</code>, such as <code>UNFCURI</code>.  <a href="group__autogenerated.html#gaaf2b167887891e46105e6462a1d0acb8">More...</a><br /></td></tr>
<tr class="separator:gaaf2b167887891e46105e6462a1d0acb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Autogenerated functions for callback registration. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__extending.html" title="Instructions to support new commands, requests and URCs.">Extending the library</a> </dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga475aa1338c7bccbf139dc2cbcd4c3154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga475aa1338c7bccbf139dc2cbcd4c3154">&#9670;&nbsp;</a></span>ucxhURC_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="ucxh__urc_8h.html#a44fe167118c2a781861ba3efcb020106">LIST_OF_PLUS_URC</a> enum <a class="el" href="group__autogenerated.html#ga1d7d80f6cae90090c604ce5615f6f064">ucxhURC_t</a> <a class="el" href="group__autogenerated.html#ga1d7d80f6cae90090c604ce5615f6f064">ucxhURC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration of all URCS, with the defined values <code>uxchURC_XXX</code> , finalized by <a class="el" href="group__autogenerated.html#gga1d7d80f6cae90090c604ce5615f6f064aafe2c22bcb47e898b9edcbc2895b0246">uxchURC_LAST</a> followed by <a class="el" href="group__autogenerated.html#gga1d7d80f6cae90090c604ce5615f6f064a5f0c50deb12c8974ce7e70b7d9101320">uxchURC_UNKNOWN</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This is autogenerated.</dd></dl>
<p>Currently not used. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga1d7d80f6cae90090c604ce5615f6f064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d7d80f6cae90090c604ce5615f6f064">&#9670;&nbsp;</a></span>ucxhURC_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__autogenerated.html#ga1d7d80f6cae90090c604ce5615f6f064">ucxhURC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration of all URCS, with the defined values <code>uxchURC_XXX</code> , finalized by <a class="el" href="group__autogenerated.html#gga1d7d80f6cae90090c604ce5615f6f064aafe2c22bcb47e898b9edcbc2895b0246">uxchURC_LAST</a> followed by <a class="el" href="group__autogenerated.html#gga1d7d80f6cae90090c604ce5615f6f064a5f0c50deb12c8974ce7e70b7d9101320">uxchURC_UNKNOWN</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This is autogenerated.</dd></dl>
<p>Currently not used. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1d7d80f6cae90090c604ce5615f6f064aafe2c22bcb47e898b9edcbc2895b0246"></a>uxchURC_LAST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga1d7d80f6cae90090c604ce5615f6f064a5f0c50deb12c8974ce7e70b7d9101320"></a>uxchURC_UNKNOWN&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ucxh__urc_8h_source.html#l00969">969</a> of file <a class="el" href="ucxh__urc_8h_source.html">ucxh_urc.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab90dcd73cc916fda9f699e8d06e6318a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab90dcd73cc916fda9f699e8d06e6318a">&#9670;&nbsp;</a></span>ucxhPARSER_setOnXXX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ucxh__urc_8h.html#a44fe167118c2a781861ba3efcb020106">LIST_OF_PLUS_URC</a> bool ucxhPARSER_setOnXXX </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_x_x_x_event__t.html">ucxhPARSER_urcXXXEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic function declaration for registration of callback for an URC or response to a command request named <code>XXX</code>, such as <code>NfcUriTagContent</code>, with the actual URC or command is <code>UUU</code>, such as <code>UNFCURI</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This is autogenerated.</dd></dl>
<p>The generated function will be declared as </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> ucxhPARSER_setOnNfcUriTagContent(<span class="keywordtype">int</span> (*callback)(ucxhPARSER_urcNfcUriTagContentEvent_t *pEvent));</div>
</div><!-- fragment --><p> Its definition is also autogenerated, including all code required to invoke the callback.</p>
<p>The actual list of function declarations are done using X-MACROS in <a class="el" href="ucxh__urc_8h.html">ucxh_urc.h</a>, based on the X-MACRO <a class="el" href="ucxh__urc_8h.html#a44fe167118c2a781861ba3efcb020106">LIST_OF_PLUS_URC</a> table defined in <a class="el" href="ucxh__urc_8h.html">ucxh_urc.h</a>. </p>

</div>
</div>
<a id="gad5b2febba2dbf74fad9eb8a728c26673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5b2febba2dbf74fad9eb8a728c26673">&#9670;&nbsp;</a></span>ucxhPARSER_setOnXXXOk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ucxh__urc_8h.html#a44fe167118c2a781861ba3efcb020106">LIST_OF_PLUS_URC</a> bool ucxhPARSER_setOnXXXOk </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic function declaration for registration of callback invoked when OK is received for a command request named <code>XXX</code>, such as <code>NfcUriTagContent</code>, with the actual command is <code>UUU</code>, such as <code>UNFCURI</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This is autogenerated.</dd></dl>
<p>The generated function will be declared as </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> ucxhPARSER_setOnNfcUriTagContentOk(<span class="keywordtype">int</span> (*callback)(<span class="keywordtype">void</span> *_));</div>
</div><!-- fragment --><p> Its definition is also autogenerated, including all code required to invoke the callback.</p>
<p>The actual list of function declarations are done using X-MACROS in <a class="el" href="ucxh__urc_8h.html">ucxh_urc.h</a>, based on the X-MACRO <a class="el" href="ucxh__urc_8h.html#a44fe167118c2a781861ba3efcb020106">LIST_OF_PLUS_URC</a> table defined in <a class="el" href="ucxh__urc_8h.html">ucxh_urc.h</a>. </p>

</div>
</div>
<a id="gac940a6334ca1ea7cf554c06f3798e961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac940a6334ca1ea7cf554c06f3798e961">&#9670;&nbsp;</a></span>ucxhPARSER_setOnXXXError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ucxh__urc_8h.html#a44fe167118c2a781861ba3efcb020106">LIST_OF_PLUS_URC</a> bool ucxhPARSER_setOnXXXError </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic function declaration for registration of callback invoked when ERROR is received for a command request named <code>XXX</code>, such as <code>NfcUriTagContent</code>, with the actual command is <code>UUU</code>, such as <code>UNFCURI</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This is autogenerated.</dd></dl>
<p>The generated function will be declared as </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> ucxhPARSER_setOnNfcUriTagContentError(<span class="keywordtype">int</span> (*callback)(<span class="keywordtype">void</span> *_));</div>
</div><!-- fragment --><p> Its definition is also autogenerated, including all code required to invoke the callback.</p>
<p>The actual list of function declarations are done using X-MACROS in <a class="el" href="ucxh__urc_8h.html">ucxh_urc.h</a>, based on the X-MACRO <a class="el" href="ucxh__urc_8h.html#a44fe167118c2a781861ba3efcb020106">LIST_OF_PLUS_URC</a> table defined in <a class="el" href="ucxh__urc_8h.html">ucxh_urc.h</a>. </p>

</div>
</div>
<a id="ga95573632ef17c4111fbe3a552705c10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95573632ef17c4111fbe3a552705c10b">&#9670;&nbsp;</a></span>ucxhPARSER_internalSetOnUUUOk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ucxh__urc_8h.html#a44fe167118c2a781861ba3efcb020106">LIST_OF_PLUS_URC</a> bool ucxhPARSER_internalSetOnUUUOk </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic function declaration for registration of <b>internal</b> callback invoked when OK is received for a command request named <code>XXX</code>, such as <code>NfcUriTagContent</code>, with the actual command is <code>UUU</code>, such as <code>UNFCURI</code>. </p>
<p>This function shall NOT be called by application code!</p>
<dl class="section note"><dt>Note</dt><dd>This is autogenerated.</dd></dl>
<p>The generated function will be declared as </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> ucxhPARSER_internalSetOnUNFCURIOk(<span class="keywordtype">int</span> (*callback)(<span class="keywordtype">void</span> *_));</div>
</div><!-- fragment --><p> Its definition is also autogenerated, including all code required to invoke the callback.</p>
<p>The actual list of function declarations are done using X-MACROS in <a class="el" href="ucxh__urc_8h.html">ucxh_urc.h</a>, based on the X-MACRO <a class="el" href="ucxh__urc_8h.html#a44fe167118c2a781861ba3efcb020106">LIST_OF_PLUS_URC</a> table defined in <a class="el" href="ucxh__urc_8h.html">ucxh_urc.h</a>. </p>

</div>
</div>
<a id="gae1dca9917b5f5361b44cb699f78bdcb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1dca9917b5f5361b44cb699f78bdcb8">&#9670;&nbsp;</a></span>ucxhPARSER_internalSetOnUUUError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ucxh__urc_8h.html#a44fe167118c2a781861ba3efcb020106">LIST_OF_PLUS_URC</a> bool ucxhPARSER_internalSetOnUUUError </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic function declaration for registration of <b>internal</b> callback invoked when ERROR is received for a command request named <code>XXX</code>, such as <code>NfcUriTagContent</code>, with the actual command is <code>UUU</code>, such as <code>UNFCURI</code>. </p>
<p>This function shall NOT be called by application code!</p>
<dl class="section note"><dt>Note</dt><dd>This is autogenerated.</dd></dl>
<p>The generated function will be declared as </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> ucxhPARSER_internalSetOnUNFCURIError(<span class="keywordtype">int</span> (*callback)(<span class="keywordtype">void</span> *_));</div>
</div><!-- fragment --><p> Its definition is also autogenerated, including all code required to invoke the callback.</p>
<p>The actual list of function declarations are done using X-MACROS in <a class="el" href="ucxh__urc_8h.html">ucxh_urc.h</a>, based on the X-MACRO <a class="el" href="ucxh__urc_8h.html#a44fe167118c2a781861ba3efcb020106">LIST_OF_PLUS_URC</a> table defined in <a class="el" href="ucxh__urc_8h.html">ucxh_urc.h</a>. </p>

</div>
</div>
<a id="gaaf2b167887891e46105e6462a1d0acb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf2b167887891e46105e6462a1d0acb8">&#9670;&nbsp;</a></span>onUUU_createEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ucxh__urc_8h.html#a44fe167118c2a781861ba3efcb020106">LIST_OF_PLUS_URC</a> <a class="el" href="ucxh__urc_8h.html#aa90077b35ac464b34ccee14ada3ceb65">ucxhURC_parseResult_t</a> onUUU_createEvent </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ppParams</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structucxh_p_a_r_s_e_r__urc_x_x_x_event__t.html">ucxhPARSER_urcXXXEvent_t</a> *&#160;</td>
          <td class="paramname"><em>pEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic function declaration for a function which parses a line to create an event for a URC or reponse to a command request <code>XXX</code>, such as <code>NfcUriTagContent</code>, with the actual URN or command is <code>UUU</code>, such as <code>UNFCURI</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This is autogenerated.</dd></dl>
<p>The generated function <b>declaration</b> will be declared as </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code" href="ucxh__urc_8h.html#aa90077b35ac464b34ccee14ada3ceb65">ucxhURC_parseResult_t</a> onNfcUriTagContent_createEvent(uint8_t numParams, <span class="keyword">const</span> <span class="keywordtype">char</span> *ppParams[], ucxhPARSER_urcNfcUriTagContentEvent_t *pEvent); </div>
</div><!-- fragment --><p>The actual definition is NOT autogenerated, and must fulfill the requirements outlined in <a class="el" href="group__extending.html">Extending the library</a> .</p>
<p>The actual list of function declarations are done using X-MACROS in <a class="el" href="ucxh__urc_8h.html">ucxh_urc.h</a>, based on the X-MACRO <a class="el" href="ucxh__urc_8h.html#a44fe167118c2a781861ba3efcb020106">LIST_OF_PLUS_URC</a> table defined in <a class="el" href="ucxh__urc_8h.html">ucxh_urc.h</a>. </p>

</div>
</div>
<a id="ga7c7062b8d1041f243f6368138dc50337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c7062b8d1041f243f6368138dc50337">&#9670;&nbsp;</a></span>ucxhPARSER_setOnManufacturerIdentification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnManufacturerIdentification </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_manufacturer_identification_event__t.html">ucxhPARSER_urcManufacturerIdentificationEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke upon reception of the <code>+GMI</code> URC or command response for <code>Manufacturer Identification</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>GMI </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>+GMI</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The event passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__eventcreation.html#ga826eb0ef4bebfc59296fe451d2e3616f" title="Create a struct ucxhPARSER_urcManufacturerIdentificationEvent_t from the parameters in a +GMI URC....">onGMI_createEvent()</a> </dd>
<dd>
ucxhPARSER_setOnXGMIError() </dd>
<dd>
<a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a" title="Generic function declaration for registration of callback for an URC or response to a command request...">ucxhPARSER_setOnXXX()</a> </dd></dl>

</div>
</div>
<a id="gaedb16ab618f1d4e7d9af1d819ce3af67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedb16ab618f1d4e7d9af1d819ce3af67">&#9670;&nbsp;</a></span>ucxhPARSER_setOnGMIError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnGMIError </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke in case the command <code>AT+GMI</code> for <code>Manufacturer Identification</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>GMI </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related AT-command:</dt><dd><ul>
<li>AT+GMI </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>ERROR</code> for <code>AT+GMI</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_</td><td>TBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961" title="Generic function declaration for registration of callback invoked when ERROR is received for a comman...">ucxhPARSER_setOnXXXError()</a> </dd></dl>

</div>
</div>
<a id="ga04e601fa515d5431d13645aa610ab425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04e601fa515d5431d13645aa610ab425">&#9670;&nbsp;</a></span>ucxhPARSER_setOnModelIdentification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnModelIdentification </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_model_identification_event__t.html">ucxhPARSER_urcModelIdentificationEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke upon reception of the <code>+GMM</code> URC or command response for <code>Model Identification</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>GMM </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>+GMM</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The event passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__eventcreation.html#ga816ff7ceb46f318e4ac0e2b7a4d03fc9" title="Create a struct ucxhPARSER_urcModelIdentificationEvent_t from the parameters in a +GMM URC....">onGMM_createEvent()</a> </dd>
<dd>
ucxhPARSER_setOnXGMMError() </dd>
<dd>
<a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a" title="Generic function declaration for registration of callback for an URC or response to a command request...">ucxhPARSER_setOnXXX()</a> </dd></dl>

</div>
</div>
<a id="ga7a629376b14c77ec1eacbfc3a0e13f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a629376b14c77ec1eacbfc3a0e13f2a">&#9670;&nbsp;</a></span>ucxhPARSER_setOnGMMError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnGMMError </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke in case the command <code>AT+GMM</code> for <code>Model Identification</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>GMM </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related AT-command:</dt><dd><ul>
<li>AT+GMM </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>ERROR</code> for <code>AT+GMM</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_</td><td>TBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961" title="Generic function declaration for registration of callback invoked when ERROR is received for a comman...">ucxhPARSER_setOnXXXError()</a> </dd></dl>

</div>
</div>
<a id="gad7cc459922610a3f978cb8687f5dccce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7cc459922610a3f978cb8687f5dccce">&#9670;&nbsp;</a></span>ucxhPARSER_setOnSoftwareVersionIdentification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnSoftwareVersionIdentification </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_software_version_identification_event__t.html">ucxhPARSER_urcSoftwareVersionIdentificationEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke upon reception of the <code>+GMR</code> URC or command response for <code>Software Version Identification</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>GMR </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>+GMR</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The event passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__eventcreation.html#ga8d73582bc018c18ee17488bbf9e22f8c" title="Create a struct ucxhPARSER_urcSoftwareVersionIdentificationEvent_t from the parameters in a +GMR URC....">onGMR_createEvent()</a> </dd>
<dd>
ucxhPARSER_setOnXGMRError() </dd>
<dd>
<a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a" title="Generic function declaration for registration of callback for an URC or response to a command request...">ucxhPARSER_setOnXXX()</a> </dd></dl>

</div>
</div>
<a id="ga516226aeaff5d4feb125430c754d2945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga516226aeaff5d4feb125430c754d2945">&#9670;&nbsp;</a></span>ucxhPARSER_setOnGMRError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnGMRError </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke in case the command <code>AT+GMR</code> for <code>Software Version Identification</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>GMR </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related AT-command:</dt><dd><ul>
<li>AT+GMR </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>ERROR</code> for <code>AT+GMR</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_</td><td>TBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961" title="Generic function declaration for registration of callback invoked when ERROR is received for a comman...">ucxhPARSER_setOnXXXError()</a> </dd></dl>

</div>
</div>
<a id="ga9def56fdbc269521fd364f7e3da29a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9def56fdbc269521fd364f7e3da29a0f">&#9670;&nbsp;</a></span>ucxhPARSER_setOnSerialNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnSerialNumber </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_serial_number_event__t.html">ucxhPARSER_urcSerialNumberEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke upon reception of the <code>+GSN</code> URC or command response for <code>Serial Number</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>GSN </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>+GSN</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The event passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__eventcreation.html#gaddd68d860a53ef722414fd90491dee18" title="Create a struct ucxhPARSER_urcSerialNumberEvent_t from the parameters in a +GSN URC....">onGSN_createEvent()</a> </dd>
<dd>
ucxhPARSER_setOnXGSNError() </dd>
<dd>
<a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a" title="Generic function declaration for registration of callback for an URC or response to a command request...">ucxhPARSER_setOnXXX()</a> </dd></dl>

</div>
</div>
<a id="ga3a14463f4e1de22bcaaf150cb2925f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a14463f4e1de22bcaaf150cb2925f6e">&#9670;&nbsp;</a></span>ucxhPARSER_setOnGSNError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnGSNError </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke in case the command <code>AT+GSN</code> for <code>Serial Number</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>GSN </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related AT-command:</dt><dd><ul>
<li>AT+GSN </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>ERROR</code> for <code>AT+GSN</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_</td><td>TBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961" title="Generic function declaration for registration of callback invoked when ERROR is received for a comman...">ucxhPARSER_setOnXXXError()</a> </dd></dl>

</div>
</div>
<a id="ga0cf633d6a1b6b6caa7e7f0389cfe0ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cf633d6a1b6b6caa7e7f0389cfe0ba1">&#9670;&nbsp;</a></span>ucxhPARSER_setOnTypeCodeIdentification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnTypeCodeIdentification </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_type_code_identification_event__t.html">ucxhPARSER_urcTypeCodeIdentificationEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke upon reception of the <code>+I0</code> URC or command response for <code>Type Code Identification</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>I0 </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>+I0</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The event passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__eventcreation.html#ga5ceaec1005e97b02a34c0302d2994a58" title="Create a struct ucxhPARSER_urcTypeCodeIdentificationEvent_t from the parameters in a +I0 URC....">onI0_createEvent()</a> </dd>
<dd>
ucxhPARSER_setOnXI0Error() </dd>
<dd>
<a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a" title="Generic function declaration for registration of callback for an URC or response to a command request...">ucxhPARSER_setOnXXX()</a> </dd></dl>

</div>
</div>
<a id="ga171bebc5bd825e69f29e1e7b73669e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga171bebc5bd825e69f29e1e7b73669e42">&#9670;&nbsp;</a></span>ucxhPARSER_setOnI0Error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnI0Error </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke in case the command <code>AT+I0</code> for <code>Type Code Identification</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>I0 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related AT-command:</dt><dd><ul>
<li>AT+I0 </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>ERROR</code> for <code>AT+I0</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_</td><td>TBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961" title="Generic function declaration for registration of callback invoked when ERROR is received for a comman...">ucxhPARSER_setOnXXXError()</a> </dd></dl>

</div>
</div>
<a id="ga2d9ec6fabf5935bb15254de3f26729f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d9ec6fabf5935bb15254de3f26729f1">&#9670;&nbsp;</a></span>ucxhPARSER_setOnIdentificationInformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnIdentificationInformation </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_identification_information_event__t.html">ucxhPARSER_urcIdentificationInformationEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke upon reception of the <code>+I9</code> URC or command response for <code>Identification Information</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>I9 </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>+I9</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The event passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__eventcreation.html#gaf5d2161f0b7d484246d6b1bc6e2bc396" title="Create a struct ucxhPARSER_urcIdentificationInformationEvent_t from the parameters in a +I9 URC....">onI9_createEvent()</a> </dd>
<dd>
ucxhPARSER_setOnXI9Error() </dd>
<dd>
<a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a" title="Generic function declaration for registration of callback for an URC or response to a command request...">ucxhPARSER_setOnXXX()</a> </dd></dl>

</div>
</div>
<a id="ga594e928f9ea1dae09aec617078d70689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga594e928f9ea1dae09aec617078d70689">&#9670;&nbsp;</a></span>ucxhPARSER_setOnI9Error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnI9Error </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke in case the command <code>AT+I9</code> for <code>Identification Information</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>I9 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related AT-command:</dt><dd><ul>
<li>AT+I9 </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>ERROR</code> for <code>AT+I9</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_</td><td>TBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961" title="Generic function declaration for registration of callback invoked when ERROR is received for a comman...">ucxhPARSER_setOnXXXError()</a> </dd></dl>

</div>
</div>
<a id="ga4dc311b2309bce52db2c240c4462f61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dc311b2309bce52db2c240c4462f61d">&#9670;&nbsp;</a></span>ucxhPARSER_setOnMcuIdentification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnMcuIdentification </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_mcu_identification_event__t.html">ucxhPARSER_urcMcuIdentificationEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke upon reception of the <code>+I10</code> URC or command response for <code>MCU Identification</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>I10 </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>+I10</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The event passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__eventcreation.html#ga5ca45d27b0cb5313aa0641d13fdeaf98" title="Create a struct ucxhPARSER_urcMcuIdentificationEvent_t from the parameters in a +I10 URC....">onI10_createEvent()</a> </dd>
<dd>
ucxhPARSER_setOnXI10Error() </dd>
<dd>
<a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a" title="Generic function declaration for registration of callback for an URC or response to a command request...">ucxhPARSER_setOnXXX()</a> </dd></dl>

</div>
</div>
<a id="ga0a16d5eae8fd6ba4c7d657011de369ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a16d5eae8fd6ba4c7d657011de369ac">&#9670;&nbsp;</a></span>ucxhPARSER_setOnI10Error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnI10Error </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke in case the command <code>AT+I10</code> for <code>MCU Identification</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>I10 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related AT-command:</dt><dd><ul>
<li>AT+I10 </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>ERROR</code> for <code>AT+I10</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_</td><td>TBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961" title="Generic function declaration for registration of callback invoked when ERROR is received for a comman...">ucxhPARSER_setOnXXXError()</a> </dd></dl>

</div>
</div>
<a id="ga0ddb8616263bb68c3fd42ca4628c6cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ddb8616263bb68c3fd42ca4628c6cf1">&#9670;&nbsp;</a></span>ucxhPARSER_setOnStartup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnStartup </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_startup_event__t.html">ucxhPARSER_urcStartupEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke upon reception of the <code>+STARTUP</code> URC or command response for <code>Startup</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>STARTUP </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>+STARTUP</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The event passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__eventcreation.html#ga4da1c006a0ad9ab08fb339e68a528273" title="Create a struct ucxhPARSER_urcStartupEvent_t from the parameters in a +STARTUP URC....">onSTARTUP_createEvent()</a> </dd>
<dd>
ucxhPARSER_setOnXSTARTUPError() </dd>
<dd>
<a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a" title="Generic function declaration for registration of callback for an URC or response to a command request...">ucxhPARSER_setOnXXX()</a> </dd></dl>

</div>
</div>
<a id="gad710f78de8dcea7213764abb79122ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad710f78de8dcea7213764abb79122ec6">&#9670;&nbsp;</a></span>ucxhPARSER_setOnSTARTUPError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnSTARTUPError </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke in case the command <code>AT+STARTUP</code> for <code>Startup</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>STARTUP </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related AT-command:</dt><dd><ul>
<li>AT+STARTUP </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>ERROR</code> for <code>AT+STARTUP</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_</td><td>TBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961" title="Generic function declaration for registration of callback invoked when ERROR is received for a comman...">ucxhPARSER_setOnXXXError()</a> </dd></dl>

</div>
</div>
<a id="gac6cbcae2b205d6067d52926e7ffd375e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6cbcae2b205d6067d52926e7ffd375e">&#9670;&nbsp;</a></span>ucxhPARSER_setOnConnectPeer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnConnectPeer </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_connect_peer_event__t.html">ucxhPARSER_urcConnectPeerEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke upon reception of the <code>+UDCP</code> URC or command response for <code>Connect Peer</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UDCP </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>+UDCP</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The event passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__eventcreation.html#ga617df188f721d7551faa2538f29dfa53" title="Create a struct ucxhPARSER_urcConnectPeerEvent_t from the parameters in a +UDCP URC....">onUDCP_createEvent()</a> </dd>
<dd>
ucxhPARSER_setOnXUDCPError() </dd>
<dd>
<a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a" title="Generic function declaration for registration of callback for an URC or response to a command request...">ucxhPARSER_setOnXXX()</a> </dd></dl>

</div>
</div>
<a id="ga8c59be527d84f8bc897136eb1f568d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c59be527d84f8bc897136eb1f568d93">&#9670;&nbsp;</a></span>ucxhPARSER_setOnUDCPError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnUDCPError </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke in case the command <code>AT+UDCP</code> for <code>Connect Peer</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UDCP </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related AT-command:</dt><dd><ul>
<li>AT+UDCP </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>ERROR</code> for <code>AT+UDCP</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_</td><td>TBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961" title="Generic function declaration for registration of callback invoked when ERROR is received for a comman...">ucxhPARSER_setOnXXXError()</a> </dd></dl>

</div>
</div>
<a id="ga25a6f80423227ce82a2a39d5237712ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25a6f80423227ce82a2a39d5237712ed">&#9670;&nbsp;</a></span>ucxhPARSER_setOnLocalAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnLocalAddress </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_local_address_event__t.html">ucxhPARSER_urcLocalAddressEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke upon reception of the <code>+UMLA</code> URC or command response for <code>Local address</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UMLA </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>+UMLA</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The event passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__eventcreation.html#ga181f3285f0926b2580f061c5eed84450" title="Create a struct ucxhPARSER_urcLocalAddressEvent_t from the parameters in a +UMLA URC....">onUMLA_createEvent()</a> </dd>
<dd>
ucxhPARSER_setOnXUMLAError() </dd>
<dd>
<a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a" title="Generic function declaration for registration of callback for an URC or response to a command request...">ucxhPARSER_setOnXXX()</a> </dd></dl>

</div>
</div>
<a id="ga778e275d844ec97607dc2ba6b1337db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga778e275d844ec97607dc2ba6b1337db2">&#9670;&nbsp;</a></span>ucxhPARSER_setOnUMLAError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnUMLAError </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke in case the command <code>AT+UMLA</code> for <code>Local address</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UMLA </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related AT-command:</dt><dd><ul>
<li>AT+UMLA </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>ERROR</code> for <code>AT+UMLA</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_</td><td>TBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961" title="Generic function declaration for registration of callback invoked when ERROR is received for a comman...">ucxhPARSER_setOnXXXError()</a> </dd></dl>

</div>
</div>
<a id="ga1540d5c6f750c71e015d108a454d6f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1540d5c6f750c71e015d108a454d6f27">&#9670;&nbsp;</a></span>ucxhPARSER_setOnNetworkStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnNetworkStatus </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_network_status_event__t.html">ucxhPARSER_urcNetworkStatusEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke upon reception of the <code>+UNSTAT</code> URC or command response for <code>Network Status</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UNSTAT </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>+UNSTAT</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The event passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__eventcreation.html#gacb40719908ef8249bd252ab0efd34cb9" title="Create a struct ucxhPARSER_urcNetworkStatusEvent_t from the parameters in a +UNSTAT URC....">onUNSTAT_createEvent()</a> </dd>
<dd>
ucxhPARSER_setOnXUNSTATError() </dd>
<dd>
<a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a" title="Generic function declaration for registration of callback for an URC or response to a command request...">ucxhPARSER_setOnXXX()</a> </dd></dl>

</div>
</div>
<a id="gacb80d1ab11f395f97bf2e98590a68503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb80d1ab11f395f97bf2e98590a68503">&#9670;&nbsp;</a></span>ucxhPARSER_setOnUNSTATError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnUNSTATError </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke in case the command <code>AT+UNSTAT</code> for <code>Network Status</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UNSTAT </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related AT-command:</dt><dd><ul>
<li>AT+UNSTAT </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>ERROR</code> for <code>AT+UNSTAT</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_</td><td>TBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961" title="Generic function declaration for registration of callback invoked when ERROR is received for a comman...">ucxhPARSER_setOnXXXError()</a> </dd></dl>

</div>
</div>
<a id="ga620eae018d67b54d143ed3f4edaffe01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga620eae018d67b54d143ed3f4edaffe01">&#9670;&nbsp;</a></span>ucxhPARSER_setOnPeerConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnPeerConnected </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_peer_connected_event__t.html">ucxhPARSER_urcPeerConnectedEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke upon reception of the <code>+UUDPC</code> URC or command response for <code>Peer Connected</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UUDPC </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>+UUDPC</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The event passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__eventcreation.html#ga57d15dfcf569c96471b6fd54a7493fab" title="Create a struct ucxhPARSER_urcPeerConnectedEvent_t from the parameters in a +UUDPC URC....">onUUDPC_createEvent()</a> </dd>
<dd>
ucxhPARSER_setOnXUUDPCError() </dd>
<dd>
<a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a" title="Generic function declaration for registration of callback for an URC or response to a command request...">ucxhPARSER_setOnXXX()</a> </dd></dl>

</div>
</div>
<a id="gacc808efca98250ba976ccabb43ee7224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc808efca98250ba976ccabb43ee7224">&#9670;&nbsp;</a></span>ucxhPARSER_setOnUUDPCError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnUUDPCError </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke in case the command <code>AT+UUDPC</code> for <code>Peer Connected</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UUDPC </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related AT-command:</dt><dd><ul>
<li>AT+UUDPC </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>ERROR</code> for <code>AT+UUDPC</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_</td><td>TBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961" title="Generic function declaration for registration of callback invoked when ERROR is received for a comman...">ucxhPARSER_setOnXXXError()</a> </dd></dl>

</div>
</div>
<a id="ga0fbfc01255c3e41493ba08c49172fcb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fbfc01255c3e41493ba08c49172fcb4">&#9670;&nbsp;</a></span>ucxhPARSER_setOnPeerDisconnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnPeerDisconnected </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_peer_disconnected_event__t.html">ucxhPARSER_urcPeerDisconnectedEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke upon reception of the <code>+UUDPD</code> URC or command response for <code>Peer Disconnected</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UUDPD </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>+UUDPD</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The event passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__eventcreation.html#ga1c5cf96ddfaf9a881131f0ce92a6b77a" title="Create a struct ucxhPARSER_urcPeerDisconnectedEvent_t from the parameters in a +UUDPD URC....">onUUDPD_createEvent()</a> </dd>
<dd>
ucxhPARSER_setOnXUUDPDError() </dd>
<dd>
<a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a" title="Generic function declaration for registration of callback for an URC or response to a command request...">ucxhPARSER_setOnXXX()</a> </dd></dl>

</div>
</div>
<a id="ga2fcaed6fd74f0a6b540c471547e46dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fcaed6fd74f0a6b540c471547e46dc6">&#9670;&nbsp;</a></span>ucxhPARSER_setOnUUDPDError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnUUDPDError </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke in case the command <code>AT+UUDPD</code> for <code>Peer Disconnected</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UUDPD </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related AT-command:</dt><dd><ul>
<li>AT+UUDPD </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>ERROR</code> for <code>AT+UUDPD</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_</td><td>TBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961" title="Generic function declaration for registration of callback invoked when ERROR is received for a comman...">ucxhPARSER_setOnXXXError()</a> </dd></dl>

</div>
</div>
<a id="gabdf48b5aa2f1ca7bef03d4f5d594b0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdf48b5aa2f1ca7bef03d4f5d594b0ee">&#9670;&nbsp;</a></span>ucxhPARSER_setOnNetworkDown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnNetworkDown </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_network_down_event__t.html">ucxhPARSER_urcNetworkDownEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke upon reception of the <code>+UUND</code> URC or command response for <code>Network Down</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UUND </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>+UUND</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The event passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__eventcreation.html#gaf826c5e49b95cb5f7f444aca68787b03" title="Create a struct ucxhPARSER_urcNetworkDownEvent_t from the parameters in a +UUND URC....">onUUND_createEvent()</a> </dd>
<dd>
ucxhPARSER_setOnXUUNDError() </dd>
<dd>
<a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a" title="Generic function declaration for registration of callback for an URC or response to a command request...">ucxhPARSER_setOnXXX()</a> </dd></dl>

</div>
</div>
<a id="ga8a9b993e8ba5dffe67ab39eb657239fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a9b993e8ba5dffe67ab39eb657239fb">&#9670;&nbsp;</a></span>ucxhPARSER_setOnUUNDError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnUUNDError </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke in case the command <code>AT+UUND</code> for <code>Network Down</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UUND </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related AT-command:</dt><dd><ul>
<li>AT+UUND </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>ERROR</code> for <code>AT+UUND</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_</td><td>TBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961" title="Generic function declaration for registration of callback invoked when ERROR is received for a comman...">ucxhPARSER_setOnXXXError()</a> </dd></dl>

</div>
</div>
<a id="gab2f48aa8352053041484f27134872d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2f48aa8352053041484f27134872d8f">&#9670;&nbsp;</a></span>ucxhPARSER_setOnNetworkUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnNetworkUp </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_network_up_event__t.html">ucxhPARSER_urcNetworkUpEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke upon reception of the <code>+UUNU</code> URC or command response for <code>Network Up</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UUNU </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>+UUNU</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The event passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__eventcreation.html#ga6d5fa1fc3805cbdda28b3811880e3092" title="Create a struct ucxhPARSER_urcNetworkUpEvent_t from the parameters in a +UUNU URC....">onUUNU_createEvent()</a> </dd>
<dd>
ucxhPARSER_setOnXUUNUError() </dd>
<dd>
<a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a" title="Generic function declaration for registration of callback for an URC or response to a command request...">ucxhPARSER_setOnXXX()</a> </dd></dl>

</div>
</div>
<a id="ga54aeacecd8f34ba2b34e384459fdd7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54aeacecd8f34ba2b34e384459fdd7f9">&#9670;&nbsp;</a></span>ucxhPARSER_setOnUUNUError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnUUNUError </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke in case the command <code>AT+UUNU</code> for <code>Network Up</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UUNU </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related AT-command:</dt><dd><ul>
<li>AT+UUNU </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>ERROR</code> for <code>AT+UUNU</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_</td><td>TBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961" title="Generic function declaration for registration of callback invoked when ERROR is received for a comman...">ucxhPARSER_setOnXXXError()</a> </dd></dl>

</div>
</div>
<a id="gafd5f9327421dd522646c7ebf842d6290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd5f9327421dd522646c7ebf842d6290">&#9670;&nbsp;</a></span>ucxhPARSER_setOnWifiLinkDisconnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnWifiLinkDisconnected </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_wifi_link_disconnected_event__t.html">ucxhPARSER_urcWifiLinkDisconnectedEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke upon reception of the <code>+UUWLD</code> URC or command response for <code>WiFi Link Disconnected</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UUWLD </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>+UUWLD</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The event passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__eventcreation.html#gac262239c5bde54a00a268424ad22335f" title="Create a struct ucxhPARSER_urcWifiLinkDisconnectedEvent_t from the parameters in a +UUWLD URC....">onUUWLD_createEvent()</a> </dd>
<dd>
ucxhPARSER_setOnXUUWLDError() </dd>
<dd>
<a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a" title="Generic function declaration for registration of callback for an URC or response to a command request...">ucxhPARSER_setOnXXX()</a> </dd></dl>

</div>
</div>
<a id="gaf5d5dfe7ec72dc1853b3fc29b4f02f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5d5dfe7ec72dc1853b3fc29b4f02f4d">&#9670;&nbsp;</a></span>ucxhPARSER_setOnUUWLDError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnUUWLDError </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke in case the command <code>AT+UUWLD</code> for <code>WiFi Link Disconnected</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UUWLD </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related AT-command:</dt><dd><ul>
<li>AT+UUWLD </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>ERROR</code> for <code>AT+UUWLD</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_</td><td>TBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961" title="Generic function declaration for registration of callback invoked when ERROR is received for a comman...">ucxhPARSER_setOnXXXError()</a> </dd></dl>

</div>
</div>
<a id="ga17f6ec7beabc9ba578dc08894f92bada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17f6ec7beabc9ba578dc08894f92bada">&#9670;&nbsp;</a></span>ucxhPARSER_setOnWifiLinkConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnWifiLinkConnected </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_wifi_link_connected_event__t.html">ucxhPARSER_urcWifiLinkConnectedEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke upon reception of the <code>+UUWLE</code> URC or command response for <code>WiFi Link Connected</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UUWLE </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>+UUWLE</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The event passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__eventcreation.html#ga2998ebee508c62d5feb9bcdfd092b470" title="Create a struct ucxhPARSER_urcWifiLinkConnectedEvent_t from the parameters in a +UUWLE URC....">onUUWLE_createEvent()</a> </dd>
<dd>
ucxhPARSER_setOnXUUWLEError() </dd>
<dd>
<a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a" title="Generic function declaration for registration of callback for an URC or response to a command request...">ucxhPARSER_setOnXXX()</a> </dd></dl>

</div>
</div>
<a id="ga46c25f6b8cb454b4b99b032278082f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46c25f6b8cb454b4b99b032278082f3c">&#9670;&nbsp;</a></span>ucxhPARSER_setOnUUWLEError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnUUWLEError </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke in case the command <code>AT+UUWLE</code> for <code>WiFi Link Connected</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UUWLE </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related AT-command:</dt><dd><ul>
<li>AT+UUWLE </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>ERROR</code> for <code>AT+UUWLE</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_</td><td>TBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961" title="Generic function declaration for registration of callback invoked when ERROR is received for a comman...">ucxhPARSER_setOnXXXError()</a> </dd></dl>

</div>
</div>
<a id="ga58642e44a4e0df5d8bd2395704afa051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58642e44a4e0df5d8bd2395704afa051">&#9670;&nbsp;</a></span>ucxhPARSER_setOnWifiStationConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnWifiStationConfiguration </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_wifi_station_configuration_event__t.html">ucxhPARSER_urcWifiStationConfigurationEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke upon reception of the <code>+UWSC</code> URC or command response for <code>WiFi Station Configuration</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UWSC </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>+UWSC</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The event passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__eventcreation.html#ga27293be6ddf8b96a24be963dc2e62d4e" title="Create a struct ucxhPARSER_urcWifiStationConfigurationEvent_t from the parameters in a +UWSC URC....">onUWSC_createEvent()</a> </dd>
<dd>
ucxhPARSER_setOnXUWSCError() </dd>
<dd>
<a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a" title="Generic function declaration for registration of callback for an URC or response to a command request...">ucxhPARSER_setOnXXX()</a> </dd></dl>

</div>
</div>
<a id="ga9a9527fddbaa4ac2452cffe550c04904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a9527fddbaa4ac2452cffe550c04904">&#9670;&nbsp;</a></span>ucxhPARSER_setOnUWSCError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnUWSCError </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke in case the command <code>AT+UWSC</code> for <code>WiFi Station Configuration</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UWSC </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related AT-command:</dt><dd><ul>
<li>AT+UWSC </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>ERROR</code> for <code>AT+UWSC</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_</td><td>TBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961" title="Generic function declaration for registration of callback invoked when ERROR is received for a comman...">ucxhPARSER_setOnXXXError()</a> </dd></dl>

</div>
</div>
<a id="gae5d24d8e8dc9fd9e44f5efb4b49902fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5d24d8e8dc9fd9e44f5efb4b49902fa">&#9670;&nbsp;</a></span>ucxhPARSER_setOnWifiScan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnWifiScan </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_wifi_scan_event__t.html">ucxhPARSER_urcWifiScanEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke upon reception of the <code>+UWSCAN</code> URC or command response for <code>WiFi Scan</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UWSCAN </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>+UWSCAN</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The event passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__eventcreation.html#ga46bcf79df46ab0ec59fc7d1654e89c9a" title="Create a struct ucxhPARSER_urcWifiScanEvent_t from the parameters in a +UWSCAN URC....">onUWSCAN_createEvent()</a> </dd>
<dd>
ucxhPARSER_setOnXUWSCANError() </dd>
<dd>
<a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a" title="Generic function declaration for registration of callback for an URC or response to a command request...">ucxhPARSER_setOnXXX()</a> </dd></dl>

</div>
</div>
<a id="gaafd42a3e00874cc98f87409ff849f8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafd42a3e00874cc98f87409ff849f8a1">&#9670;&nbsp;</a></span>ucxhPARSER_setOnUWSCANError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnUWSCANError </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke in case the command <code>AT+UWSCAN</code> for <code>WiFi Scan</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UWSCAN </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related AT-command:</dt><dd><ul>
<li>AT+UWSCAN </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>ERROR</code> for <code>AT+UWSCAN</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_</td><td>TBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961" title="Generic function declaration for registration of callback invoked when ERROR is received for a comman...">ucxhPARSER_setOnXXXError()</a> </dd></dl>

</div>
</div>
<a id="gaee0b7ebf53c869cc63322273467f8249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee0b7ebf53c869cc63322273467f8249">&#9670;&nbsp;</a></span>ucxhPARSER_setOnWifiStationStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnWifiStationStatus </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structucxh_p_a_r_s_e_r__urc_wifi_station_status_event__t.html">ucxhPARSER_urcWifiStationStatusEvent_t</a> *pEvent)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke upon reception of the <code>+UWSSTAT</code> URC or command response for <code>WiFi Station Status</code> The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga3d9d53a6926208b98c74b70b10b23258">ucxhPARSER_setOnURCParsed()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UWSSTAT </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>+UWSSTAT</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The event passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__eventcreation.html#ga86a955ecdc933306a3ace164f114edd4" title="Create a struct ucxhPARSER_urcWifiStationStatusEvent_t from the parameters in a +UWSSTAT URC....">onUWSSTAT_createEvent()</a> </dd>
<dd>
ucxhPARSER_setOnXUWSSTATError() </dd>
<dd>
<a class="el" href="group__autogenerated.html#gab90dcd73cc916fda9f699e8d06e6318a" title="Generic function declaration for registration of callback for an URC or response to a command request...">ucxhPARSER_setOnXXX()</a> </dd></dl>

</div>
</div>
<a id="ga23f42d85e3e123b814e2160bfa4e80af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23f42d85e3e123b814e2160bfa4e80af">&#9670;&nbsp;</a></span>ucxhPARSER_setOnUWSSTATError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ucxhPARSER_setOnUWSSTATError </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *_)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback to invoke in case the command <code>AT+UWSSTAT</code> for <code>WiFi Station Status</code> failed with <code>ERROR</code>. The callback is invoked independent of if the URC is received in AT mode or through the EDM AT channel. If no callback is registered, the callback optinally registered with <code><a class="el" href="group__parsercallbacks.html#ga0ac498e7dfa87351668a6deefb9a03a9">ucxhPARSER_setOnErrorReceived()</a></code> will be invoked instead. </p>
<dl class="section note"><dt>Note</dt><dd>This function is automatically generated. </dd></dl>
<dl class="section user"><dt>Related URC:</dt><dd><ul>
<li>UWSSTAT </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related AT-command:</dt><dd><ul>
<li>AT+UWSSTAT </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to invoke upon reception of <code>ERROR</code> for <code>AT+UWSSTAT</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_</td><td>TBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if registration succeeded, FALSE otherwize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__autogenerated.html#gac940a6334ca1ea7cf554c06f3798e961" title="Generic function declaration for registration of callback invoked when ERROR is received for a comman...">ucxhPARSER_setOnXXXError()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aucxh__urc_8h_html_aa90077b35ac464b34ccee14ada3ceb65"><div class="ttname"><a href="ucxh__urc_8h.html#aa90077b35ac464b34ccee14ada3ceb65">ucxhURC_parseResult_t</a></div><div class="ttdeci">ucxhURC_parseResult_t</div><div class="ttdef"><b>Definition:</b> <a href="ucxh__urc_8h_source.html#l00087">ucxh_urc.h:87</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
