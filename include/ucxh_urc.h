/**
 \copyright Copyright (C) 2020 u-blox 

u-blox reserves all rights in this deliverable (documentation, software, etc.,
hereafter “Deliverable”). 

u-blox grants you the right to use, copy, modify and distribute the
Deliverable provided hereunder for any purpose without fee.

THIS DELIVERABLE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
WARRANTY. IN PARTICULAR, NEITHER THE AUTHOR NOR U-BLOX MAKES ANY
REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
DELIVERABLE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.

In case you provide us a feedback or make a contribution in the form of a
further development of the Deliverable (“Contribution”), u-blox will have the
same rights as granted to you, namely to use, copy, modify and distribute the
Contribution provided to us for any purpose without fee.

Component:  u-connectXpress Host Library
\file
*/


#ifndef _UCXH_AT_URC_H
#define _UCXH_AT_URC_H

#include "ucxh_parser.h"



/** List of parsed URCs and responses from a command request, using X-MACROS.
 * 
 * Apart from being central to the X-MACROS, The `mkdocs.sh` script file extracts data from this table
 *  to autogenerate documentation.
 * \par Format:
 * * `URC` excluding initial '+' and trailing ':'
 * * `Name` as described in AT Command Manual
 * * `Identifier` CamelCase identifier, based on the Name. Functions and types will be autogenerated based on this identifier
 * * `Finalizer` `NULL` or \ref ucxhURC_MUST_FINALIZE, in which case `onUUU_createEvent(0, NULL, ... )` will be invoked upon OK
 *    or ucxhURC_NO_COLON if URC doesn't need trailing ':' (typically only +STARTUP).
 * * `Callback` `NULL` or \ref ucxhURC_CALLBACK_ON_OK, in which case the registered internal callback will be invoked upon OK.
 * \note In the file, ensure this list is sorted by URC
 */
// __BEGIN_GREP_MAGIC__ -- DO NOT REMOVE THIS LINE
#define LIST_OF_PLUS_URC \
_XMACRO(GMI,     "Manufacturer Identification",     ManufacturerIdentification,       NULL,                  NULL) \
_XMACRO(GMM,     "Model Identification",            ModelIdentification,              NULL,                  NULL) \
_XMACRO(GMR,     "Software Version Identification", SoftwareVersionIdentification,    NULL,                  NULL) \
_XMACRO(GSN,     "Serial Number",                   SerialNumber,                     NULL,                  NULL) \
_XMACRO(I0,	     "Type Code Identification",     	  TypeCodeIdentification,           NULL,                  NULL) \
_XMACRO(I9,      "Identification Information",      IdentificationInformation,        NULL,                  NULL) \
_XMACRO(I10,	   "MCU Identification",              McuIdentification,                NULL,                  NULL) \
_XMACRO(STARTUP, "Startup",                         Startup,                          ucxhURC_NO_COLON,      NULL) \
_XMACRO(UDCP,    "Connect Peer",                    ConnectPeer,                      NULL,                  NULL) \
_XMACRO(UMLA,    "Local address",                   LocalAddress,                     NULL,                  NULL) \
_XMACRO(UNSTAT,  "Network Status",                  NetworkStatus,                    ucxhURC_MUST_FINALIZE, ucxhURC_CALLBACK_ON_OK) \
_XMACRO(UUDPC,   "Peer Connected",                  PeerConnected,                    NULL,                  NULL) \
_XMACRO(UUDPD,   "Peer Disconnected",               PeerDisconnected,                 NULL,                  NULL) \
_XMACRO(UUND,    "Network Down",                    NetworkDown,                      NULL,                  NULL) \
_XMACRO(UUNU,    "Network Up",                      NetworkUp,                        NULL,                  NULL) \
_XMACRO(UUWLD,   "WiFi Link Disconnected",          WifiLinkDisconnected,             NULL,                  NULL) \
_XMACRO(UUWLE,   "WiFi Link Connected",             WifiLinkConnected,                NULL,                  NULL) \
_XMACRO(UWSC,    "WiFi Station Configuration",      WifiStationConfiguration,         NULL,                  ucxhURC_CALLBACK_ON_OK) \
_XMACRO(UWSCAN,  "WiFi Scan",                       WifiScan,                         NULL,                  NULL) \
_XMACRO(UWSSTAT, "WiFi Station Status",             WifiStationStatus,                NULL,                  NULL)
// __END_GREP_MAGIC__ -- DO NOT REMOVE THIS LINE


///////////////////////////////////////////////////////////////////////////////

/** Magic value that will prevent any callback from being invoked, unless
 * ucxhURC_PARSE_RESULT_OK or ucxhURC_PARSE_RESULT_ERROR is returned.
 */
#define ucxhURC_MUST_FINALIZE ((void *)true)

/** Magic value that will allow certain URCs to not have traling ':' (+STARTUP)
 */
#define ucxhURC_NO_COLON ((void *)(uint32_t)':')

/** Magic value that will invoke the callback upon reception of OK.
 */
#define ucxhURC_CALLBACK_ON_OK ((void *)true)

/** Return values from onXXX_CreateEvent() methods.
 */
typedef enum ucxhURC_parseResult_t {
  ucxhURC_PARSE_RESULT_OK,  // Parsing succeed: Event is valid
  ucxhURC_PARSE_RESULT_ERROR,// Impossible to parse correctly
  ucxhURC_PARSE_RESULT_NEED_MORE  // Parsing ok so far, but needs (at leas) one more invocation to finalize
} ucxhURC_parseResult_t;


///////////////////////////////////////////////////////////////////////////////


/*! 
*  @{
* \ingroup urcevents_ip_params
*/

/** Size TBD
 */
#define ucxhAT_INTERFACE_HARDWARE_ADDRESS_MAX_LEN 64

#define ucxhAT_ipV4AddrStr_MAX_LEN (3+1+3+1+3+1+3)

/** Format such as "192.168.0.242"
 */
typedef char ucxhAT_ipV4AddrStr_t[ucxhAT_ipV4AddrStr_MAX_LEN+1];

#define ucxhAT_ipV6AddrStr_MAX_LEN (4+1+4+1+4+1+4+1+4+1+4+1+4+1+4)

/** Formats such as  "2001:0db8:85a3:0000:0000:8a2e:0370:7334" , "2001:0db8:85a3:::8a2e:0370:7334", ""::"
 */
typedef char ucxhAT_ipV6AddrStr_t[ucxhAT_ipV6AddrStr_MAX_LEN+1];

#define ucxhURC_INTERFACE_ID_ALL 254
#define ucxhURC_INTERFACE_ID_NONE 255

typedef uint8_t ucxhPARSER_networkInterfaceId_t;
typedef uint8_t ucxhPARSER_connectionId_t;
typedef uint16_t ucxhPARSER_wifiChannel_t;
typedef uint8_t ucxhPARSER_peerHandle_t;

#define ucxhAT_macAddrStr_MAX_LEN (2*6)

/** Format such as "AABBCCDDEEFF"
 */
typedef char ucxhAT_macAddrStr_t[ucxhAT_macAddrStr_MAX_LEN+1];

/** Size TBD
 */
#define ucxhAT_ssidStr_MAX_LEN (32)

typedef char ucxhAT_ssidStr_t[ucxhAT_ssidStr_MAX_LEN+1];


typedef enum ucxhAT_ipV6AddrStatusState_t {
    ucxhURC_IPV6_ADDR_STATUS_STATE_INVALID = 0,
    ucxhURC_IPV6_ADDR_STATUS_STATE_TENTATIVE = 1,
    ucxhURC_IPV6_ADDR_STATUS_STATE_PREFERRED = 2,
    ucxhURC_IPV6_ADDR_STATUS_STATE_DEPRECATED = 3
} ucxhAT_ipV6AddrStatusState_t;


typedef struct ucxhAT_ipV6GenericAddrStr_t {
    ucxhAT_ipV6AddrStatusState_t ipv6_status_state;
    ucxhAT_ipV6AddrStr_t ipv6_address;   
} ucxhAT_ipV6GenericAddrStr_t;

/*! @} */


///////////////////////////////////////////////////////////////////////////////



/*! 
*  @{
* \ingroup urcevents_network_params
*/

typedef enum {
  ucxhURC_INTERFACE_TYPE_UNKNOWN = 0,
  ucxhURC_INTERFACE_TYPE_WIFI_STATION = 1,
  ucxhURC_INTERFACE_TYPE_WIFI_AP = 2,
  ucxhURC_INTERFACE_TYPE_ETHERNET = 3,
  ucxhURC_INTERFACE_TYPE_PPP = 4,
  ucxhURC_INTERFACE_TYPE_BRIDGE = 5,
  ucxhURC_INTERFACE_TYPE_PAN = 6
} ucxhPARSER_interfaceType_t;


typedef enum {
    ucxhURC_NETWORK_STATUS_DOWN = 0,
    ucxhURC_NETWORK_STATUS_UP = 1
} ucxhPARSER_urcUNSTATNetworkStatus_t;

/** Maximum number of characters in the +UNSTAT: status_val field.
 */
#define ucxhAT_NETWORK_STATUS_VAL_MAX_LEN ucxhAT_RESPONSE_MAX_LEN

typedef uint8_t ucxhPARSER_peerId_t;

typedef enum ucxhPARSER_peerURLScheme_t {
  ucxhPARSER_PEER_URL_SCHEME_UNDEFINED = 0,
  //ucxhPARSER_PEER_URL_SCHEME_SPS,
  //ucxhPARSER_PEER_URL_SCHEME_SPP,
  //ucxhPARSER_PEER_URL_SCHEME_DUN,
  ucxhPARSER_PEER_URL_SCHEME_TCP,
  //ucxhPARSER_PEER_URL_SCHEME_UDP,
  ucxhPARSER_PEER_URL_SCHEME_MQTT,
} ucxhPARSER_peerURLScheme_t;

#define ucxhAT_BdAddrStr_MAX_LEN (2*6+1)
typedef char ucxhAT_BdAddrStr_t[ucxhAT_BdAddrStr_MAX_LEN+1];

typedef char ucxhAT_BtNameStr_t[16+1]; //!< Size TBD

typedef enum {
  ucxhPARSER_BLE_REMOTE_ROLE_PERIPHERAL,
  ucxhPARSER_BLE_REMOTE_ROLE_CENTRAL,
} ucxhPARSER_BleRemoteRole_t;

/** Size TBD
 */
#define ucxhAT_BtUuid_MAX_LEN 63
typedef char ucxhAT_BtUuidStr_t[ucxhAT_BtUuid_MAX_LEN+1]; 

/** Size TBD
 */
#define ucxhAT_urlHost_MAX_LEN 127
typedef char uxchAT_urlHostStr_t[ucxhAT_urlHost_MAX_LEN+1]; 

typedef uint16_t ucxhAT_IpPortNumber;

typedef enum ucxhAT_TlsVersion_t {
  ucshAT_TLS_VERSION_1_0 = 1,
  ucshAT_TLS_VERSION_1_1 = 2,
  ucshAT_TLS_VERSION_1_2 = 3,
} ucxhAT_TlsVersion_t;

#define ucxhAT_certificateInternalNameStr_MAX_LEN 32
typedef char ucxhAT_certificateInternalNameStr_t[ucxhAT_certificateInternalNameStr_MAX_LEN+1];

/** Size TBD
*/
#define ucxhAT_mqttParameterStr_MAX_LEN 128
typedef char ucxhAT_mqttParameterStr_t[ucxhAT_mqttParameterStr_MAX_LEN+1];

/**
 * \note This type is quite large. Consider declaring it static instead of as stack-local.
 */
typedef struct ucxhPARSER_peerURL_t {
  ucxhPARSER_peerURLScheme_t scheme;
  union {
    struct {
      ucxhAT_BdAddrStr_t domain;
      struct {
        ucxhAT_BtNameStr_t bt_name;
        ucxhPARSER_BleRemoteRole_t role;
        bool escseq;
      } query;
    } sps;

    struct {
      ucxhAT_BdAddrStr_t domain;
      struct {
        ucxhAT_BtUuidStr_t uuid;
        bool qos;
        bool escseq;
      } query;
    } spp_dun;

    struct {
      uxchAT_urlHostStr_t domain;
      ucxhAT_IpPortNumber remote_port;
      struct {
        ucxhAT_IpPortNumber local_port;
        bool flush_tx;
        struct {
          uint32_t idle_ms;
          uint32_t interval_ms;
          uint16_t count;
        } keep_alive;
        struct {
          ucxhAT_certificateInternalNameStr_t ca;
          ucxhAT_certificateInternalNameStr_t cert;
          ucxhAT_certificateInternalNameStr_t priv_key;
          ucxhAT_TlsVersion_t encr;
        };
      } query;
    } tcp;

    struct {
      uxchAT_urlHostStr_t domain;
      ucxhAT_IpPortNumber remote_port;
      struct {
        ucxhAT_IpPortNumber local_port;
        bool enable_reception_from_unicast_address;
      };
    } udp;

    struct {
      uxchAT_urlHostStr_t domain;
      ucxhAT_IpPortNumber remote_port;
      struct {
        ucxhAT_mqttParameterStr_t client;
        ucxhAT_mqttParameterStr_t user;
        ucxhAT_mqttParameterStr_t password;
        ucxhAT_mqttParameterStr_t publish_topic;
        ucxhAT_mqttParameterStr_t subscribe_topic;
        ucxhAT_TlsVersion_t encr;
      } query;
    } mqtt;

  };

} ucxhPARSER_peerURL_t;

typedef struct ucxhPARSER_defaultRemotePeerParam_t {
  ucxhPARSER_peerId_t peer_id; //!< Avoid setting this to anything but 0 or doing after AT+UDCP
  ucxhPARSER_peerURL_t url;
  struct {
    struct {
      bool always_connected;
      // uint32_t ac_to; // ???
    };
    bool external_connect;
  } connect_scheme;  
} ucxhPARSER_defaultRemotePeerParam_t;

/*! @} */

///////////////////////////////////////////////////////////////////////////////


/*! 
*  @{
* \ingroup urcevents_system_params
*/

typedef enum ucxhPARSER_hardwareInterfaceId_t {
  ucxhPARSER_HARDWARE_INTERFACE_BLUETOOTH = 1,
  ucxhPARSER_HARDWARE_INTERFACE_WIFI_STATION = 2,
  ucxhPARSER_HARDWARE_INTERFACE_ETHERNET = 3,
  ucxhPARSER_HARDWARE_INTERFACE_WIFI_AP = 4,
} ucxhPARSER_hardwareInterfaceId_t;

/*! @} */

/*! 
*  @{
* \ingroup urcevents_system
*/

/**
 * \urc +UMLA
 */
typedef struct ucxhPARSER_urcLocalAddressEvent_t {
  ucxhPARSER_hardwareInterfaceId_t interface_id; //!< \warning: NOT the same as ucxhPARSER_networkInterfaceId_t
  ucxhAT_macAddrStr_t mac_address;
} ucxhPARSER_urcLocalAddressEvent_t;

/*! @} */


///////////////////////////////////////////////////////////////////////////////

/*! 
*  @{
* \ingroup urcevents_general_params
*/

typedef char ucxhPARSER_urcTypeCodeIdentificationStr_t[31+1];                       // "ODIN-W262-04B-00"
                                                                                    // "NINA-W152-00B-00"
typedef char ucxhPARSER_urcIdentificationInformationApplicationVersionStr_t[23+1];  // "7.1.0-020"
typedef char ucxhPARSER_urcIdentificationInformationUidStr_t[63+1];                 // "ODIN-W26X-7.1.0-020-0-g61cbc2d3020"
                                                                                    // "NINA-W13X-2.1.0-017-0-g253211b6"
typedef char ucxhPARSER_urcMcuIdentificationStr_t[31+1];                            // "3E0046000B513831333630"
                                                                                    // "000000000000246F28119B14"
typedef char ucxhPARSER_urcManufacturerIdentificationStr_t[15+1];                   // "u-blox"
typedef char ucxhPARSER_urcModelIdentificationStr_t[15+1];                          // "ODIN-W2"
                                                                                    // "NINA-W132"
typedef char ucxhPARSER_urcSerialNumberStr_t[31+1];                                 // "0233965902929793"
                                                                                    // "0233965910595296"


/*! @} */

/*! 
*  @{
* \ingroup urcevents_general
*/

/**
 * \urc I0
 */
typedef struct ucxhPARSER_urcTypeCodeIdentificationEvent_t {  
  ucxhPARSER_urcTypeCodeIdentificationStr_t  type_code;
} ucxhPARSER_urcTypeCodeIdentificationEvent_t;

/**
 * \urc I9
 */
typedef struct ucxhPARSER_urcIdentificationInformationEvent_t {  
  ucxhPARSER_urcIdentificationInformationApplicationVersionStr_t  application_version;
  ucxhPARSER_urcIdentificationInformationUidStr_t unique_identifier;
} ucxhPARSER_urcIdentificationInformationEvent_t;

/**
 * \urc I10
 */
typedef struct ucxhPARSER_urcMcuIdentificationEvent_t {  
  ucxhPARSER_urcMcuIdentificationStr_t  mcu_identification;
} ucxhPARSER_urcMcuIdentificationEvent_t;

/**
 * \urc +GMI
 */
typedef struct ucxhPARSER_urcManufacturerIdentificationEvent_t {
  ucxhPARSER_urcManufacturerIdentificationStr_t manufacturer;
} ucxhPARSER_urcManufacturerIdentificationEvent_t;

/**
 * \urc +GMM
 */
typedef struct ucxhPARSER_urcModelIdentificationEvent_t {
  ucxhPARSER_urcModelIdentificationStr_t model;
} ucxhPARSER_urcModelIdentificationEvent_t;

/**
 * \urc +GSN
 */
typedef struct ucxhPARSER_urcSerialNumberEvent_t {
  ucxhPARSER_urcSerialNumberStr_t serial_number;
} ucxhPARSER_urcSerialNumberEvent_t;

/**
 * \urc +GMR
 */
typedef struct ucxhPARSER_urcSoftwareVersionIdentificationEvent_t {
  ucxhPARSER_urcIdentificationInformationApplicationVersionStr_t software_version;
} ucxhPARSER_urcSoftwareVersionIdentificationEvent_t;

/**
 * \urc +STARTUP
 */

typedef struct ucxhPARSER_urcStartupEvent_t {
  uint8_t _;
} ucxhPARSER_urcStartupEvent_t;

/*! @} */

///////////////////////////////////////////////////////////////////////////////


/*! 
*  @{
* \ingroup directat
*/

/** \brief Read Type Code Identification
 * \cmd ATI0
 * \event ucxhPARSER_urcTypeCodeIdentificationEvent_t
 */
bool ucxhCOMMAND_readTypeCodeIdentification(void);

/** \brief Read Identification Information
 * \cmd ATI9
 * \event ucxhPARSER_urcIdentificationInformationEvent_t
 * \sa ucxhCOMMAND_readSoftwareVersionIdentification()
 */
bool ucxhCOMMAND_readIdentificationInformation(void);

/** \brief Read Mcu Identification
 * \cmd ATI10
 * \event ucxhPARSER_urcMcuIdentificationEvent_t
 */
bool ucxhCOMMAND_readMcuIdentification(void);

/** \brief Read Serial Number
 * \cmd AT+GSN
 * \event ucxhPARSER_urcSerialNumberEvent_t
 */
bool ucxhCOMMAND_readSerialNumber(void);

/** \brief Read Software Version Identification
 * \cmd AT+GMR
 * \event ucxhPARSER_urcSoftwareVersionIdentificationEvent_t
 * \sa ucxhCOMMAND_readIdentificationInformation()
 */
bool ucxhCOMMAND_readSoftwareVersionIdentification(void);

/** \brief Read Model Identification
 * \cmd AT+GMM
 * \event ucxhPARSER_urcModelIdentificationEvent_t
 */
bool ucxhCOMMAND_readModelIdentification(void);

/** \brief Read Manufacturer Identification
 * \cmd AT+GMI
 * \event ucxhPARSER_urcManufacturerIdentificationEvent_t
 */
bool ucxhCOMMAND_readManufacturerIdentification(void);

/** \brief Read Local Address
 * \cmd AT+UMLA
 * \event ucxhPARSER_urcLocalAddressEvent_t
 */
bool ucxhCOMMAND_readLocalAddress(ucxhPARSER_hardwareInterfaceId_t interface_id);

/** \brief Write Default Remote Peer
 * \cmd AT+UDDRP
 */
bool ucxhCOMMAND_writeDefaultRemotePeer(ucxhPARSER_defaultRemotePeerParam_t *param);

/** \brief Connect Peer
 * \cmd AT+UDCP
 */
bool ucxhCOMMAND_connectPeer(ucxhPARSER_peerURL_t *pUrl);

/** \brief Wifi Scan
 * \cmd AT+UWSCAN
 */
bool ucxhCOMMAND_WifiScan(void);

/*! @} */






///////////////////////////////////////////////////////////////////////////////





/*! 
*  @{
* \ingroup urcevents_wifi_params
*/

typedef enum ucxhURC_wifiDisconnectReason_t {
  URC_WIFI_DISCONNECT_REASON_UNKNOWN = 0,
  URC_WIFI_DISCONNECT_REASON_REMOTE_CLOSE = 1,
  URC_WIFI_DISCONNECT_REASON_OUT_OF_RANGE = 2,
  URC_WIFI_DISCONNECT_REASON_ROAMING = 3,
  URC_WIFI_DISCONNECT_REASON_SECURITY_PROBLEM = 4,
  URC_WIFI_DISCONNECT_REASON_NETWORK_DISABLED = 5
} ucxhURC_wifiDisconnectReason_t;


typedef enum ucxhPARSER_wifiStationStatus_t {
  ucxhPARSER_WIFI_STATION_STATUS_DISABLED = 0,
  ucxhPARSER_WIFI_STATION_STATUS_DISCONNECTED = 1,
  ucxhPARSER_WIFI_STATION_STATUS_CONNECTED = 2
} ucxhPARSER_wifiStationStatus_t;

typedef enum ucxhPARSER_wifiRegion_t {
  ucxhPARSER_WIFI_REGION_WORLD = 0,
  ucxhPARSER_WIFI_REGION_FCC = 1,
  ucxhPARSER_WIFI_REGION_ETSI = 2,
  ucxhPARSER_WIFI_REGION_ALL = 3,
} ucxhPARSER_wifiRegion_t; 

typedef enum ucxhURC_wifiStationStatusId_t {
  ucxhURC_WIFI_STATION_STATUS_SSID            = 0,
  ucxhURC_WIFI_STATION_STATUS_BSSID           = 1,
  ucxhURC_WIFI_STATION_STATUS_CHANNEL         = 2,
  ucxhURC_WIFI_STATION_STATUS_STATUS          = 4,
  ucxhURC_WIFI_STATION_STATUS_RSSI            = 6,
  // ucxhURC_WIFI_STATION_STATUS_MOBILITY_DOMAIN = 7,
  ucxhURC_WIFI_STATION_STATUS_REGION          = 8
} ucxhURC_wifiStationStatusId_t;

#define ucxhPARSER_WIFI_STATION_STATUS_RSSI_DISCONNECTED -32768

/*! @} */

/*! 
*  @{
* \ingroup urcevents_wifi
*/

/**
 * \urc +UUWLD
 */
typedef struct ucxhPARSER_urcWifiLinkDisconnectedEvent_t {  
  ucxhPARSER_connectionId_t connection_id;
  ucxhURC_wifiDisconnectReason_t reason;
} ucxhPARSER_urcWifiLinkDisconnectedEvent_t;


/**
 * \urc +UUWLE
 */
typedef struct ucxhPARSER_urcWifiLinkConnectedEvent_t {  
  ucxhPARSER_connectionId_t connection_id;
  ucxhPARSER_wifiChannel_t channel;
  ucxhAT_macAddrStr_t bssid;
} ucxhPARSER_urcWifiLinkConnectedEvent_t;


/**
 * \urc +UWSC
 */
typedef struct ucxhPARSER_urcWifiStationConfigurationEvent_t {
  // TODO
} ucxhPARSER_urcWifiStationConfigurationEvent_t;


/**
 * \urc +UWSSTAT
 */
typedef struct ucxhPARSER_urcWifiStationStatusEvent_t {
  ucxhURC_wifiStationStatusId_t status_id;
  union {
    ucxhAT_ssidStr_t ssid;
    ucxhAT_macAddrStr_t bssid;
    ucxhPARSER_wifiChannel_t channel;
    ucxhPARSER_wifiStationStatus_t status;
    int16_t rssi;
    // TODO:  mobility_domain;
    ucxhPARSER_wifiRegion_t region;
  };

} ucxhPARSER_urcWifiStationStatusEvent_t;


/**
 * \urc +UWSCAN
 */
typedef struct ucxhPARSER_urcWifiScanEvent_t {
  ucxhAT_macAddrStr_t bssid;
  // TODO: op_mode
  ucxhAT_ssidStr_t ssid;
  ucxhPARSER_wifiChannel_t channel;
  int16_t rssi;
  // TODO: authentication_suites
  // TODO: unicast_ciphers
  // TODO: group_cihpers
  // TODO: rsn_cap
  // TODO: country_code
  // TODO: mob_domain
} ucxhPARSER_urcWifiScanEvent_t;

/*! @} */


///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////

/*! 
*  @{
* \ingroup urcevents_data_params
*/

#define ucxhAT_ipV6GenericAddr_MAX 3

typedef enum ucxhURC_peerType_t {
  ucxhURC_PEER_TYPE_BLUETOOTH = 1,
  ucxhURC_PEER_TYPE_IPV4 = 2,
  ucxhURC_PEER_TYPE_IPV6 = 3
} ucxhURC_peerType_t;

typedef enum ucxhURC_ipProtocol_t {
    ucxhURC_IP_PROTOCOL_TCP = 0,
    ucxhURC_IP_PROTOCOL_UDP = 1,
    ucxhURC_IP_PROTOCOL_MQTT = 6
} ucxhURC_ipProtocol_t;

/*! @} */

/*! 
*  @{
* \ingroup urcevents_data
*/

/**
 * \urc +UUDPC
 */
typedef struct ucxhPARSER_urcPeerConnectedEvent_t {  
  ucxhPARSER_peerHandle_t peer_handle;
  ucxhURC_peerType_t type;

  union {
    struct {
      ucxhAT_IpPortNumber local_port;
      ucxhAT_IpPortNumber remote_port;
      ucxhURC_ipProtocol_t protocol;
      ucxhAT_ipV4AddrStr_t local_address;
      ucxhAT_ipV4AddrStr_t remote_address;
    } ipv4_peer;

    struct {
      ucxhAT_IpPortNumber local_port;
      ucxhAT_IpPortNumber remote_port;
      ucxhURC_ipProtocol_t protocol;
      ucxhAT_ipV6AddrStr_t local_address;
      ucxhAT_ipV6AddrStr_t remote_address;
    } ipv6_peer;

    struct {
      // profile
      // address
      // frame_size
    } bluetooth_peer; // TODO: Bluetooth peer
  };

} ucxhPARSER_urcPeerConnectedEvent_t;


/**
 * \urc +UUDPD
 */
typedef struct ucxhPARSER_urcPeerDisconnectedEvent_t {  
  ucxhPARSER_peerHandle_t peer_handle;
} ucxhPARSER_urcPeerDisconnectedEvent_t;

/*! @} */




///////////////////////////////////////////////////////////////////////////////




/*! 
*  @{
* \ingroup urcevents_network
*/

/**
 * \urc +UDCP
 */

typedef struct ucxhPARSER_urcConnectPeerEvent_t {  
  ucxhPARSER_peerId_t peer_id;
} ucxhPARSER_urcConnectPeerEvent_t;

/**
 * \urc +UUND
 */
typedef struct ucxhPARSER_urcNetworkDownEvent_t {  
  ucxhPARSER_networkInterfaceId_t interface_id; //!< \warning: NOT the same as ucxhPARSER_hardwareInterfaceId_t
} ucxhPARSER_urcNetworkDownEvent_t;


/**
 * \urc +UUNU
 */
typedef struct ucxhPARSER_urcNetworkUpEvent_t {  
  ucxhPARSER_networkInterfaceId_t interface_id;//!< \warning: NOT the same as ucxhPARSER_hardwareInterfaceId_t
} ucxhPARSER_urcNetworkUpEvent_t;

/**
 * \urc +UNSTAT
 */
typedef struct ucxhPARSER_urcNetworkStatusEvent_t {
  char interface_hardware_address[ucxhAT_INTERFACE_HARDWARE_ADDRESS_MAX_LEN+1];
  ucxhPARSER_networkInterfaceId_t interface_id;//!< \warning: NOT the same as ucxhPARSER_hardwareInterfaceId_t
  ucxhPARSER_urcUNSTATNetworkStatus_t network_status;
  ucxhPARSER_interfaceType_t interface_type;
  ucxhAT_ipV4AddrStr_t ipv4_address;
  ucxhAT_ipV4AddrStr_t ipv4_subnet_mask;
  ucxhAT_ipV4AddrStr_t ipv4_gateway;  
  ucxhAT_ipV4AddrStr_t primary_dns_server;
  ucxhAT_ipV4AddrStr_t secondary_dns_server;
  ucxhAT_ipV6AddrStr_t ipv6_link_local_address;
  ucxhAT_ipV6GenericAddrStr_t ipv6_address[ucxhAT_ipV6GenericAddr_MAX];
} ucxhPARSER_urcNetworkStatusEvent_t;




/*! @} */


///////////////////////////////////////////////////////////////////////////////

/* Autogeneration of function declaration follows */


/*! 
*  @{
* \ingroup urcevents_autogenerated
* \brief Automatically generated function declarations, callback registration functions and enums.
* 
* These are generated using the X-MACRO \ref LIST_OF_PLUS_URC table defined in ucxh_urc.h
*/

// Dymmy for doxygen.
#define _XMACRO(_1, _2, _3, _4, _5)
  LIST_OF_PLUS_URC
#undef _XMACRO

/** \brief Generic event declaration for an URC or response to a 
 * command request named 
 * `XXX`, such as `NfcUriTagContent`.
 * 
 * The generated event must be declared as 
 * \code
 *   typedef struct ucxhPARSER_urcNfcUriTagContentEvent_t {
 *      ...
 *   };
 * \endcode
 * 
 * The actual list of function declarations are done using X-MACROS in ucxh_urc.h,
 * based on the X-MACRO \ref LIST_OF_PLUS_URC table defined in ucxh_urc.h.
 */

typedef struct ucxhPARSER_urcXXXEvent_t {
  void *_;
} ucxhPARSER_urcXXXEvent_t;

// Dymmy for doxygen.
#define _XMACRO(_1, _2, _3, _4, _5)
  LIST_OF_PLUS_URC
#undef _XMACRO

/** \brief Generic function declaration for registration of callback for
 * an URC or response to a command request named 
 * `XXX`, such as `NfcUriTagContent`, with the actual URC or command is `UUU`, such as `UNFCURI`.
 * 
 * \autogenerated
 * 
 * The generated function will be declared as
 * \code
 *   bool ucxhPARSER_setOnNfcUriTagContent(int (*callback)(ucxhPARSER_urcNfcUriTagContentEvent_t *pEvent));
 * \endcode
 * Its definition is also autogenerated, including all code required to invoke the callback.
 * 
 * The actual list of function declarations are done using X-MACROS in ucxh_urc.h,
 * based on the X-MACRO \ref LIST_OF_PLUS_URC table defined in ucxh_urc.h.
 */
bool ucxhPARSER_setOnXXX(int (*callback)(ucxhPARSER_urcXXXEvent_t *pEvent));

#define _XMACRO(_1, _2, URCIdentifier, _4, _5) \
  extern bool ucxhPARSER_setOn##URCIdentifier(int (*callback)(ucxhPARSER_urc##URCIdentifier##Event_t *pEvent));

  LIST_OF_PLUS_URC
#undef _XMACRO

/** \brief Generic function declaration for registration of callback invoked when
 * OK is received for a command request named
 * `XXX`, such as `NfcUriTagContent`, with the actual command is `UUU`, such as `UNFCURI`.
 * 
 * \autogenerated
 * 
 * The generated function will be declared as
 * \code
 *    bool ucxhPARSER_setOnNfcUriTagContentOk(int (*callback)(void *_));
 * \endcode
 * Its definition is also autogenerated, including all code required to invoke the callback.
 * 
 * The actual list of function declarations are done using X-MACROS in ucxh_urc.h,
 * based on the X-MACRO \ref LIST_OF_PLUS_URC table defined in ucxh_urc.h.
 */
bool ucxhPARSER_setOnXXXOk(int (*callback)(void *_));
#define _XMACRO(_1, _2, URCIdentifier, _4, _5) \
  extern bool ucxhPARSER_setOn##URCIdentifier##Ok(int (*callback)(void *_));

  LIST_OF_PLUS_URC
#undef _XMACRO

/** \brief Generic function declaration for registration of callback invoked when
 * ERROR is received for a command request named
 * `XXX`, such as `NfcUriTagContent`, with the actual command is `UUU`, such as `UNFCURI`.
 * 
 * \autogenerated
 * 
 * The generated function will be declared as
 * \code
 * bool ucxhPARSER_setOnNfcUriTagContentError(int (*callback)(void *_));
 * \endcode
 * Its definition is also autogenerated, including all code required to invoke the callback.
 * 
 * The actual list of function declarations are done using X-MACROS in ucxh_urc.h,
 * based on the X-MACRO \ref LIST_OF_PLUS_URC table defined in ucxh_urc.h.
 */

bool ucxhPARSER_setOnXXXError(int (*callback)(void *_));
#define _XMACRO(_1, _2, URCIdentifier, _4, _5) \
  extern bool ucxhPARSER_setOn##URCIdentifier##Error(int (*callback)(void *_));

  LIST_OF_PLUS_URC
#undef _XMACRO




/** \brief Generic function declaration for registration of \b internal callback invoked when
 * OK is received for a command request named
 * `XXX`, such as `NfcUriTagContent`, with the actual command is `UUU`, such as `UNFCURI`.
 * 
 * This function shall NOT be called by application code!

 * \autogenerated
 * \protected
 * 
 * The generated function will be declared as
 * \code
 *    bool ucxhPARSER_internalSetOnUNFCURIOk(int (*callback)(void *_));
 * \endcode
 * Its definition is also autogenerated, including all code required to invoke the callback.
 * 
 * The actual list of function declarations are done using X-MACROS in ucxh_urc.h,
 * based on the X-MACRO \ref LIST_OF_PLUS_URC table defined in ucxh_urc.h.
 */
bool ucxhPARSER_internalSetOnUUUOk(int (*callback)(void *_));
#define _XMACRO(URCName, _2, _3, _4, _5) \
  extern bool ucxhPARSER_internalSetOn##URCName##Ok(int (*callback)(void *_));

  LIST_OF_PLUS_URC
#undef _XMACRO

/** \brief Generic function declaration for registration of \b internal callback invoked when
 * ERROR is received for a command request named
 * `XXX`, such as `NfcUriTagContent`, with the actual command is `UUU`, such as `UNFCURI`.
 * 
 * This function shall NOT be called by application code!
 * 
 * \autogenerated
 * \protected
 * 
 * The generated function will be declared as
 * \code
 * bool ucxhPARSER_internalSetOnUNFCURIError(int (*callback)(void *_));
 * \endcode
 * Its definition is also autogenerated, including all code required to invoke the callback.
 * 
 * The actual list of function declarations are done using X-MACROS in ucxh_urc.h,
 * based on the X-MACRO \ref LIST_OF_PLUS_URC table defined in ucxh_urc.h.
 */

bool ucxhPARSER_internalSetOnUUUError(int (*callback)(void *_));
#define _XMACRO(URCName, _2, _3, _4, _5) \
  extern bool ucxhPARSER_internalSetOn##URCName##Error(int (*callback)(void *_));

  LIST_OF_PLUS_URC
#undef _XMACRO

/** \brief Generic function declaration for a function which parses a line to create an event for
 * a URC or reponse to a command request 
 * `XXX`, such as `NfcUriTagContent`, with the actual URN or command is `UUU`, such as `UNFCURI`.
 * 
 * \autogenerated
 * 
 * The generated function \b declaration will be declared as
 * \code
 *   extern ucxhURC_parseResult_t onNfcUriTagContent_createEvent(uint8_t numParams, const char *ppParams[], ucxhPARSER_urcNfcUriTagContentEvent_t *pEvent); 
 * \endcode
 *
 * The actual definition is NOT autogenerated, and must fulfill the requirements outlined in \ref extending .
 * 
 * The actual list of function declarations are done using X-MACROS in ucxh_urc.h,
 * based on the X-MACRO \ref LIST_OF_PLUS_URC table defined in ucxh_urc.h.
 */
  extern ucxhURC_parseResult_t onUUU_createEvent(uint8_t numParams, const char *ppParams[], ucxhPARSER_urcXXXEvent_t *pEvent);
#define _XMACRO(URCName, _2, URCIdentifier, _4, _5) \
  extern ucxhURC_parseResult_t on##URCName##_createEvent(uint8_t numParams, const char *ppParams[], ucxhPARSER_urc##URCIdentifier##Event_t *pEvent);

  LIST_OF_PLUS_URC
#undef _XMACRO

// Dymmy for doxygen.
#define _XMACRO(_1, _2, _3, _4, _5)
  LIST_OF_PLUS_URC
#undef _XMACRO

/**
 * \brief Enumeration of all URCS, with the defined values `uxchURC_XXX` , finalized by \ref uxchURC_LAST followed by \ref uxchURC_UNKNOWN
 * 
 * \autogenerated
 * 
 * Currently not used.
 */
typedef enum ucxhURC_t {
  #define _XMACRO(urc, _2, Identifier, _4, _5) uxchURC_##Identifier , 

    LIST_OF_PLUS_URC
  #undef _XMACRO 
  
  uxchURC_LAST,
  uxchURC_UNKNOWN
} ucxhURC_t;

/*! @} */


/** \brief Quick way to create an event which only contains a string or integer as response.
 * \param URC URC, such as `GMM`, as defined in \ref LIST_OF_PLUS_URC
 * \param identifier Identifier, such as `ModelIdentification`, as defined in \ref LIST_OF_PLUS_URC
 * \param TYPE `ARRAY` or `INT` (will invoke STRCPY2ARRAYORFAIL() or STRCPY2INTORFAIL(), correspondingly)
 * \param field Field of the Event, such as `model`.
 * \return ucxhURC_PARSE_RESULT_OK or ucxhURC_PARSE_RESULT_ERROR
 */
#define TRIVIAL_EVENT(URC, identifier, TYPE, field) \
ucxhURC_parseResult_t on##URC##_createEvent(uint8_t numParams, const char *ppParams[], ucxhPARSER_urc##identifier##Event_t *pEvent) \
{ \
    ucxhURC_parseResult_t result = ucxhURC_PARSE_RESULT_OK; \
    ucxhPARSER_urc##identifier##Event_t event = {0}; \
    \
    assert(pEvent != NULL); \
    ASSERTPARAMS(numParams, ppParams, 2); \
    \
    STRCPY2##TYPE##ORFAIL(event.field, ppParams[1]); \
    \
    memcpy(pEvent, &event, sizeof(*pEvent)); \
    return ucxhURC_PARSE_RESULT_OK; \
}

/** \brief Quick way to create an event which contains no response at all.
 * The resulting Event_t will containt a dummy uint8_t, to allow a valid sizeof().
 * \param URC URC, such as `STARTUP`, as defined in \ref LIST_OF_PLUS_URC
 * \param identifier Identifier, such as `Startup`, as defined in \ref LIST_OF_PLUS_URC
 * \return ucxhURC_PARSE_RESULT_OK or ucxhURC_PARSE_RESULT_ERROR
 */
#define EMPTY_EVENT(URC, identifier) \
ucxhURC_parseResult_t on##URC##_createEvent(uint8_t numParams, const char *ppParams[], ucxhPARSER_urc##identifier##Event_t *pEvent) \
{ \
    ucxhURC_parseResult_t result = ucxhURC_PARSE_RESULT_OK; \
    ucxhPARSER_urc##identifier##Event_t event = {0}; \
    \
    assert(pEvent != NULL); \
    ASSERTPARAMS(numParams, ppParams, 1); \
    \
    return ucxhURC_PARSE_RESULT_OK; \
}

#include "autogenerated.h"

#endif